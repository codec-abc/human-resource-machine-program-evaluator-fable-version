{"version":3,"sources":["webpack:///webpack/bootstrap 285d62b23682c7ffac33","webpack:///./~/fable-core/Util.js","webpack:///./~/fable-core/Seq.js","webpack:///./~/fable-core/Symbol.js","webpack:///./~/fable-core/Date.js","webpack:///./~/fable-core/List.js","webpack:///./~/fable-core/ListClass.js","webpack:///./~/fable-core/Map.js","webpack:///./~/fable-core/GenericComparer.js","webpack:///./~/fable-core/Long.js","webpack:///./~/fable-core/RegExp.js","webpack:///./~/fable-core/Set.js","webpack:///./~/fable-core/String.js","webpack:///./output/hmrpEvaluator.js","webpack:///./~/fable-core/Array.js","webpack:///./~/fable-core/Reflection.js","webpack:///./~/fable-core/Serialize.js","webpack:///./~/fable-core/TimeSpan.js","webpack:///(webpack)/buildin/global.js","webpack:///./output/worker.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACO;AACR;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sBAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,aAAa;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,+FAA8C,SAAS,sCAAsC,EAAE;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrSiB;AACC;AACgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gDAAgD;AAChD;AACA,CAAC;AACO;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,8BAA8B,6BAA6B,iDAAiD,EAAE,MAAM,EAAE;AACtH;AACA;AACA,8BAA8B,6BAA6B,8CAA8C,EAAE,KAAK,EAAE;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,wCAAwC,eAAe,EAAE,wBAAwB,gBAAgB,EAAE;AACnG;AACA;AACA;AACA,kBAAkB;AAClB,2CAA2C,+BAA+B,EAAE;AAC5E;AACA;AACA;AACA;AACA,+BAA+B,eAAe,EAAE;AAChD;AACA;AACA,sCAAsC,mCAAmC,EAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,sDAAsD,4GAAsC,EAAE,EAAE;AACxJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAqD,EAAE;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB,EAAE;AACzD;AACA;AACA,uCAAuC,uBAAuB,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qCAAqC,EAAE;AAC3E,KAAK;AACL;AACA;AACA;AACA,oCAAoC,sBAAsB,EAAE;AAC5D,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa,EAAE;AACzC;AACA;AACA,8BAA8B,gBAAgB,EAAE;AAChD;AACA;AACA,6BAA6B,gBAAgB,EAAE;AAC/C;AACA;AACA,iCAAiC,mBAAmB,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,UAAU,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB,EAAE;AACpD;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,KAAK,yBAAyB,EAAE;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8GAAwC,EAAE;AAC/E;AACA;AACA,qCAAqC,oHAA8C,EAAE;AACrF;AACA;AACA,qCAAqC,+GAAyC,EAAE;AAChF;AACA;AACA,qCAAqC,qHAA+C,EAAE;AACtF;AACA;AACA,+CAA+C,wBAAwB,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6BAA6B,8EAA8E,EAAE,SAAS,EAAE;AACtJ;AACA;AACA,8BAA8B,6BAA6B,yEAAyE,EAAE,SAAS,EAAE;AACjJ;AACA;AACA;AACA;AACA;AACA,6BAA6B,UAAU,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA,sCAAsC,UAAU,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,2CAA2C,kBAAkB,EAAE;AAC/D;AACA;AACA,gCAAgC,qCAAqC,EAAE;AACvE;AACA;AACA,kBAAkB;AAClB;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yCAAyC,EAAE;AAC/E,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB,EAAE;AACrD;AACA;AACA,mCAAmC,mBAAmB,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,2CAA2C,aAAa,EAAE;AAC1D;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,4BAA4B;AAC5B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iCAAiC,eAAe,EAAE;AAClD;AACA;AACA,oCAAoC,kBAAkB,EAAE;AACxD;;;;;;;;;AClqBA;AAAA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBmC;AACF;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,uBAAuB,OAAO;AAC9B,uBAAuB,OAAO;AAC9B,wBAAwB,QAAQ;AAChC,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/MA;AACwB;AACE;AACQ;AACJ;AACE;AAChC;AACkB;AAClB;AACA,wGAAsC,gFAAyB,EAAE;AACjE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wGAAsC,0BAA0B,EAAE;AAClE;AACA;AACA,iCAAiC,UAAU,EAAE;AAC7C;AACA;AACA,gHAA8C,6FAAsC,EAAE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,gHAA8C,mFAA4B,EAAE;AAC5E;AACA;AACA,mHAAiD,sFAA+B,EAAE;AAClF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sCAAsC,UAAU,EAAE;AAClD;AACA;AACA,wGAAsC,gFAAyB,EAAE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mHAAiD,2IAAoF,EAAE;AACvI;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,8KAA0C,kGAAgC,EAAE;AAC5E;;;;;;;;;;;AC9EA;AACmB;AACF;AACC;AAClB;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvFA;AACiC;AACd;AACF;AACC;AAClB;AACA;AACwB;AACE;AACA;AACM;AACQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wBAAwB,EAAE;AAC5D;AACA;AACA,6CAA6C,8BAA8B,EAAE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACO;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,uGAAqC,cAAc,EAAE;AACrD;AACA;AACA,uGAAqC,cAAc,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;wDACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAsC,2GAAqC,EAAE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAkC,uCAAuC,EAAE;AAC3E;AACA;AACA,uGAAqC,uCAAuC,EAAE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACthBkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACO;AACR;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kBAAkB;AAChD,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,EAAE;AACnC;AACA;AACA,oCAAoC,EAAE;AACtC;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9FA;AACiC;AACd;AACnB;AACA;AACgC;AACN;AACI;AACA;AACA;AACA;AACJ;AAC1B;AACA,uGAAqC,eAAe,EAAE;AACtD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oCAAoC,UAAU,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACO;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oCAAoC;AACxE,wCAAwC,4DAA4D;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iCAAiC,EAAE;AACxE;AACA;AACA,qCAAqC,iCAAiC,EAAE,iCAAiC,kCAAkC,EAAE;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,UAAU;AAC3C,wCAAwC,qCAAqC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6KAA2G;AAClJ,iDAAiD,2LAAyH;AAC1K,kDAAkD,2LAAyH;AAC3K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;wDACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA6B,aAAa,EAAE;AAC5C;AACA;AACA,wGAAsC,sBAAsB,EAAE;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA6B,gBAAgB,EAAE;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA6B;AAC7B;AACA,KAAK,EAAE;AACP;AACA;AACA,0GAAwC,0BAA0B,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAuC,oBAAoB,EAAE,qGAAmC,qBAAqB,EAAE;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAuC,oBAAoB,EAAE;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,sCAAsC,EAAE;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC35BmB;AACK;AACP;AACA;AACA;AACF;AACD;AACE;AACD;AACf;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,gCAAgC,sDAAsD,kCAAkC,EAAE,iBAAiB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,EAAE,QAAQ,EAAE,UAAU,GAAG,KAAK,EAAE,KAAK;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,0FAAkB,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjYA;AAAA,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAErI;AAClB;AACsH;AACrF;AACa;AACP;AACvC;AACmB;AACF;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,sHAAoC,uBAAuB;AAC3D;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,gEAAgE;AAC1H;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kEAAkE,mEAAmE;AACrI;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;;ACz0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa,EAAE;AAChD;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,aAAa;AACnD;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AClF2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,8DAA8D,EAAE;AACtH;AACA;AACA,CAAC;AACO;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mCAAmC,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wDAAwD,EAAE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yDAAyD,EAAE;AACjG;AACA;AACA;AACA;AACA;AACA,yHAAmD,eAAe,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC9KA;AACkB;AAClB;AACiC;AACjC;AACA;AAC8B;AACA;AACP;AACC;AACE;AACX;AAC2B;AACb;AACV;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gDAAgD,EAAE;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mHAA8C,kBAAkB,UAAU,EAAE,GAAG,6DAA6D;AAC5I;AACA;AACA;AACA,0CAA0C,kBAAkB;AAC5D;AACA;AACA,4GAA4G;AAC5G,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB,EAAE;AAC3D;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,oBAAoB,EAAE,IAAI,EAAE;AAClF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjViC;AACjC;AACA;AACA,uBAAuB,OAAO;AAC9B,uBAAuB,OAAO;AAC9B,uBAAuB,OAAO;AAC9B,uBAAuB,OAAO;AAC9B,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClFA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;ACpBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,6BAA6B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,C","file":"hmrpEvaluator.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 18);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 285d62b23682c7ffac33","import FSymbol from \"./Symbol\";\r\nvar NonDeclaredType = (function () {\r\n    function NonDeclaredType(kind, definition, generics) {\r\n        this.kind = kind;\r\n        this.definition = definition;\r\n        this.generics = generics;\r\n    }\r\n    NonDeclaredType.prototype.Equals = function (other) {\r\n        if (this.kind === other.kind && this.definition === other.definition) {\r\n            return typeof this.generics === \"object\"\r\n                ? equalsRecords(this.generics, other.generics)\r\n                : this.generics === other.generics;\r\n        }\r\n        return false;\r\n    };\r\n    return NonDeclaredType;\r\n}());\r\nexport { NonDeclaredType };\r\nexport var Any = new NonDeclaredType(\"Any\");\r\nexport var Unit = new NonDeclaredType(\"Unit\");\r\nexport function Option(t) {\r\n    return new NonDeclaredType(\"Option\", null, t);\r\n}\r\nfunction FableArray(t, isTypedArray) {\r\n    if (isTypedArray === void 0) { isTypedArray = false; }\r\n    var def = null, genArg = null;\r\n    if (isTypedArray) {\r\n        def = t;\r\n    }\r\n    else {\r\n        genArg = t;\r\n    }\r\n    return new NonDeclaredType(\"Array\", def, genArg);\r\n}\r\nexport { FableArray as Array };\r\nexport function Tuple(ts) {\r\n    return new NonDeclaredType(\"Tuple\", null, ts);\r\n}\r\nexport function GenericParam(definition) {\r\n    return new NonDeclaredType(\"GenericParam\", definition);\r\n}\r\nexport function Interface(definition) {\r\n    return new NonDeclaredType(\"Interface\", definition);\r\n}\r\nexport function makeGeneric(typeDef, genArgs) {\r\n    return new NonDeclaredType(\"GenericType\", typeDef, genArgs);\r\n}\r\nexport function isGeneric(typ) {\r\n    return typ instanceof NonDeclaredType && typ.kind === \"GenericType\";\r\n}\r\nexport function getDefinition(typ) {\r\n    return isGeneric(typ) ? typ.definition : typ;\r\n}\r\nexport function extendInfo(cons, info) {\r\n    var parent = Object.getPrototypeOf(cons.prototype);\r\n    if (typeof parent[FSymbol.reflection] === \"function\") {\r\n        var newInfo_1 = {}, parentInfo_1 = parent[FSymbol.reflection]();\r\n        Object.getOwnPropertyNames(info).forEach(function (k) {\r\n            var i = info[k];\r\n            if (typeof i === \"object\") {\r\n                newInfo_1[k] = Array.isArray(i)\r\n                    ? (parentInfo_1[k] || []).concat(i)\r\n                    : Object.assign(parentInfo_1[k] || {}, i);\r\n            }\r\n            else {\r\n                newInfo_1[k] = i;\r\n            }\r\n        });\r\n        return newInfo_1;\r\n    }\r\n    return info;\r\n}\r\nexport function hasInterface(obj, interfaceName) {\r\n    if (interfaceName === \"System.Collections.Generic.IEnumerable\") {\r\n        return typeof obj[Symbol.iterator] === \"function\";\r\n    }\r\n    else if (typeof obj[FSymbol.reflection] === \"function\") {\r\n        var interfaces = obj[FSymbol.reflection]().interfaces;\r\n        return Array.isArray(interfaces) && interfaces.indexOf(interfaceName) > -1;\r\n    }\r\n    return false;\r\n}\r\nexport function getPropertyNames(obj) {\r\n    if (obj == null) {\r\n        return [];\r\n    }\r\n    var propertyMap = typeof obj[FSymbol.reflection] === \"function\" ? obj[FSymbol.reflection]().properties || [] : obj;\r\n    return Object.getOwnPropertyNames(propertyMap);\r\n}\r\nexport function isArray(obj) {\r\n    return Array.isArray(obj) || ArrayBuffer.isView(obj);\r\n}\r\nexport function getRestParams(args, idx) {\r\n    for (var _len = args.length, restArgs = Array(_len > idx ? _len - idx : 0), _key = idx; _key < _len; _key++)\r\n        restArgs[_key - idx] = args[_key];\r\n    return restArgs;\r\n}\r\nexport function toString(o) {\r\n    return o != null && typeof o.ToString == \"function\" ? o.ToString() : String(o);\r\n}\r\nexport function hash(x) {\r\n    var s = JSON.stringify(x);\r\n    var h = 5381, i = 0, len = s.length;\r\n    while (i < len) {\r\n        h = (h * 33) ^ s.charCodeAt(i++);\r\n    }\r\n    return h;\r\n}\r\nexport function equals(x, y) {\r\n    if (x === y)\r\n        return true;\r\n    else if (x == null)\r\n        return y == null;\r\n    else if (y == null)\r\n        return false;\r\n    else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y))\r\n        return false;\r\n    else if (typeof x.Equals === \"function\")\r\n        return x.Equals(y);\r\n    else if (Array.isArray(x)) {\r\n        if (x.length != y.length)\r\n            return false;\r\n        for (var i = 0; i < x.length; i++)\r\n            if (!equals(x[i], y[i]))\r\n                return false;\r\n        return true;\r\n    }\r\n    else if (ArrayBuffer.isView(x)) {\r\n        if (x.byteLength !== y.byteLength)\r\n            return false;\r\n        var dv1 = new DataView(x.buffer), dv2 = new DataView(y.buffer);\r\n        for (var i = 0; i < x.byteLength; i++)\r\n            if (dv1.getUint8(i) !== dv2.getUint8(i))\r\n                return false;\r\n        return true;\r\n    }\r\n    else if (x instanceof Date)\r\n        return x.getTime() == y.getTime();\r\n    else\r\n        return false;\r\n}\r\nexport function compare(x, y) {\r\n    if (x === y)\r\n        return 0;\r\n    if (x == null)\r\n        return y == null ? 0 : -1;\r\n    else if (y == null)\r\n        return 1;\r\n    else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y))\r\n        return -1;\r\n    else if (typeof x.CompareTo === \"function\")\r\n        return x.CompareTo(y);\r\n    else if (Array.isArray(x)) {\r\n        if (x.length != y.length)\r\n            return x.length < y.length ? -1 : 1;\r\n        for (var i = 0, j = 0; i < x.length; i++)\r\n            if ((j = compare(x[i], y[i])) !== 0)\r\n                return j;\r\n        return 0;\r\n    }\r\n    else if (ArrayBuffer.isView(x)) {\r\n        if (x.byteLength != y.byteLength)\r\n            return x.byteLength < y.byteLength ? -1 : 1;\r\n        var dv1 = new DataView(x.buffer), dv2 = new DataView(y.buffer);\r\n        for (var i = 0, b1 = 0, b2 = 0; i < x.byteLength; i++) {\r\n            b1 = dv1.getUint8(i), b2 = dv2.getUint8(i);\r\n            if (b1 < b2)\r\n                return -1;\r\n            if (b1 > b2)\r\n                return 1;\r\n        }\r\n        return 0;\r\n    }\r\n    else if (x instanceof Date)\r\n        return compare(x.getTime(), y.getTime());\r\n    else\r\n        return x < y ? -1 : 1;\r\n}\r\nexport function equalsRecords(x, y) {\r\n    if (x === y) {\r\n        return true;\r\n    }\r\n    else {\r\n        var keys = getPropertyNames(x);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            if (!equals(x[keys[i]], y[keys[i]]))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexport function compareRecords(x, y) {\r\n    if (x === y) {\r\n        return 0;\r\n    }\r\n    else {\r\n        var keys = getPropertyNames(x);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var res = compare(x[keys[i]], y[keys[i]]);\r\n            if (res !== 0)\r\n                return res;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\nexport function equalsUnions(x, y) {\r\n    if (x === y) {\r\n        return true;\r\n    }\r\n    else if (x.Case !== y.Case) {\r\n        return false;\r\n    }\r\n    else {\r\n        for (var i = 0; i < x.Fields.length; i++) {\r\n            if (!equals(x.Fields[i], y.Fields[i]))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexport function compareUnions(x, y) {\r\n    if (x === y) {\r\n        return 0;\r\n    }\r\n    else {\r\n        var res = compare(x.Case, y.Case);\r\n        if (res !== 0)\r\n            return res;\r\n        for (var i = 0; i < x.Fields.length; i++) {\r\n            res = compare(x.Fields[i], y.Fields[i]);\r\n            if (res !== 0)\r\n                return res;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\nexport function createDisposable(f) {\r\n    return _a = {\r\n            Dispose: f\r\n        },\r\n        _a[FSymbol.reflection] = function () { return { interfaces: [\"System.IDisposable\"] }; },\r\n        _a;\r\n    var _a;\r\n}\r\nexport function createObj(fields) {\r\n    var iter = fields[Symbol.iterator]();\r\n    var cur = iter.next(), o = {};\r\n    while (!cur.done) {\r\n        o[cur.value[0]] = cur.value[1];\r\n        cur = iter.next();\r\n    }\r\n    return o;\r\n}\r\nexport function toPlainJsObj(source) {\r\n    if (source != null && source.constructor != Object) {\r\n        var target = {};\r\n        var props = Object.getOwnPropertyNames(source);\r\n        for (var i = 0; i < props.length; i++) {\r\n            target[props[i]] = source[props[i]];\r\n        }\r\n        var proto = Object.getPrototypeOf(source);\r\n        if (proto != null) {\r\n            props = Object.getOwnPropertyNames(proto);\r\n            for (var i = 0; i < props.length; i++) {\r\n                var prop = Object.getOwnPropertyDescriptor(proto, props[i]);\r\n                if (prop.value) {\r\n                    target[props[i]] = prop.value;\r\n                }\r\n                else if (prop.get) {\r\n                    target[props[i]] = prop.get.apply(source);\r\n                }\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n    else {\r\n        return source;\r\n    }\r\n}\r\nexport function round(value, digits) {\r\n    if (digits === void 0) { digits = 0; }\r\n    var m = Math.pow(10, digits);\r\n    var n = +(digits ? value * m : value).toFixed(8);\r\n    var i = Math.floor(n), f = n - i;\r\n    var e = 1e-8;\r\n    var r = (f > 0.5 - e && f < 0.5 + e) ? ((i % 2 == 0) ? i : i + 1) : Math.round(n);\r\n    return digits ? r / m : r;\r\n}\r\nexport function randomNext(min, max) {\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n}\r\nexport function defaultArg(arg, defaultValue, f) {\r\n    return arg == null ? defaultValue : (f != null ? f(arg) : arg);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/Util.js\n// module id = 0\n// module chunks = 0","import { equals } from \"./Util\";\r\nimport { compare } from \"./Util\";\r\nimport { permute as arrayPermute } from \"./Array\";\r\nimport List from \"./ListClass\";\r\nvar Enumerator = (function () {\r\n    function Enumerator(iter) {\r\n        this.iter = iter;\r\n    }\r\n    Enumerator.prototype.MoveNext = function () {\r\n        var cur = this.iter.next();\r\n        this.current = cur.value;\r\n        return !cur.done;\r\n    };\r\n    Object.defineProperty(Enumerator.prototype, \"Current\", {\r\n        get: function () {\r\n            return this.current;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Enumerator.prototype.Reset = function () {\r\n        throw new Error(\"JS iterators cannot be reset\");\r\n    };\r\n    Enumerator.prototype.Dispose = function () { };\r\n    return Enumerator;\r\n}());\r\nexport { Enumerator };\r\nexport function getEnumerator(o) {\r\n    return typeof o.GetEnumerator === \"function\"\r\n        ? o.GetEnumerator() : new Enumerator(o[Symbol.iterator]());\r\n}\r\nexport function toIterator(en) {\r\n    return {\r\n        next: function () {\r\n            return en.MoveNext()\r\n                ? { done: false, value: en.Current }\r\n                : { done: true, value: null };\r\n        }\r\n    };\r\n}\r\nfunction __failIfNone(res) {\r\n    if (res == null)\r\n        throw new Error(\"Seq did not contain any matching element\");\r\n    return res;\r\n}\r\nexport function toList(xs) {\r\n    return foldBack(function (x, acc) {\r\n        return new List(x, acc);\r\n    }, xs, new List());\r\n}\r\nexport function ofList(xs) {\r\n    return delay(function () { return unfold(function (x) { return x.tail != null ? [x.head, x.tail] : null; }, xs); });\r\n}\r\nexport function ofArray(xs) {\r\n    return delay(function () { return unfold(function (i) { return i < xs.length ? [xs[i], i + 1] : null; }, 0); });\r\n}\r\nexport function append(xs, ys) {\r\n    return delay(function () {\r\n        var firstDone = false;\r\n        var i = xs[Symbol.iterator]();\r\n        var iters = [i, null];\r\n        return unfold(function () {\r\n            var cur;\r\n            if (!firstDone) {\r\n                cur = iters[0].next();\r\n                if (!cur.done) {\r\n                    return [cur.value, iters];\r\n                }\r\n                else {\r\n                    firstDone = true;\r\n                    iters = [null, ys[Symbol.iterator]()];\r\n                }\r\n            }\r\n            cur = iters[1].next();\r\n            return !cur.done ? [cur.value, iters] : null;\r\n        }, iters);\r\n    });\r\n}\r\nexport function average(xs) {\r\n    var count = 1;\r\n    var sum = reduce(function (acc, x) {\r\n        count++;\r\n        return acc + x;\r\n    }, xs);\r\n    return sum / count;\r\n}\r\nexport function averageBy(f, xs) {\r\n    var count = 1;\r\n    var sum = reduce(function (acc, x) {\r\n        count++;\r\n        return (count === 2 ? f(acc) : acc) + f(x);\r\n    }, xs);\r\n    return sum / count;\r\n}\r\nexport function concat(xs) {\r\n    return delay(function () {\r\n        var iter = xs[Symbol.iterator]();\r\n        var output = null;\r\n        return unfold(function (innerIter) {\r\n            var hasFinished = false;\r\n            while (!hasFinished) {\r\n                if (innerIter == null) {\r\n                    var cur = iter.next();\r\n                    if (!cur.done) {\r\n                        innerIter = cur.value[Symbol.iterator]();\r\n                    }\r\n                    else {\r\n                        hasFinished = true;\r\n                    }\r\n                }\r\n                else {\r\n                    var cur = innerIter.next();\r\n                    if (!cur.done) {\r\n                        output = cur.value;\r\n                        hasFinished = true;\r\n                    }\r\n                    else {\r\n                        innerIter = null;\r\n                    }\r\n                }\r\n            }\r\n            return innerIter != null && output != null ? [output, innerIter] : null;\r\n        }, null);\r\n    });\r\n}\r\nexport function collect(f, xs) {\r\n    return concat(map(f, xs));\r\n}\r\nexport function choose(f, xs) {\r\n    var trySkipToNext = function (iter) {\r\n        var cur = iter.next();\r\n        if (!cur.done) {\r\n            var y = f(cur.value);\r\n            return y != null ? [y, iter] : trySkipToNext(iter);\r\n        }\r\n        return void 0;\r\n    };\r\n    return delay(function () {\r\n        return unfold(function (iter) {\r\n            return trySkipToNext(iter);\r\n        }, xs[Symbol.iterator]());\r\n    });\r\n}\r\nexport function compareWith(f, xs, ys) {\r\n    var nonZero = tryFind(function (i) { return i != 0; }, map2(function (x, y) { return f(x, y); }, xs, ys));\r\n    return nonZero != null ? nonZero : count(xs) - count(ys);\r\n}\r\nexport function delay(f) {\r\n    return _a = {},\r\n        _a[Symbol.iterator] = function () { return f()[Symbol.iterator](); },\r\n        _a;\r\n    var _a;\r\n}\r\nexport function empty() {\r\n    return unfold(function () { return void 0; });\r\n}\r\nexport function enumerateWhile(cond, xs) {\r\n    return concat(unfold(function () { return cond() ? [xs, true] : null; }));\r\n}\r\nexport function enumerateThenFinally(xs, finalFn) {\r\n    return delay(function () {\r\n        var iter;\r\n        try {\r\n            iter = xs[Symbol.iterator]();\r\n        }\r\n        catch (err) {\r\n            return void 0;\r\n        }\r\n        finally {\r\n            finalFn();\r\n        }\r\n        return unfold(function (iter) {\r\n            try {\r\n                var cur = iter.next();\r\n                return !cur.done ? [cur.value, iter] : null;\r\n            }\r\n            catch (err) {\r\n                return void 0;\r\n            }\r\n            finally {\r\n                finalFn();\r\n            }\r\n        }, iter);\r\n    });\r\n}\r\nexport function enumerateUsing(disp, work) {\r\n    var isDisposed = false;\r\n    var disposeOnce = function () {\r\n        if (!isDisposed) {\r\n            isDisposed = true;\r\n            disp.Dispose();\r\n        }\r\n    };\r\n    try {\r\n        return enumerateThenFinally(work(disp), disposeOnce);\r\n    }\r\n    catch (err) {\r\n        return void 0;\r\n    }\r\n    finally {\r\n        disposeOnce();\r\n    }\r\n}\r\nexport function exactlyOne(xs) {\r\n    var iter = xs[Symbol.iterator]();\r\n    var fst = iter.next();\r\n    if (fst.done)\r\n        throw new Error(\"Seq was empty\");\r\n    var snd = iter.next();\r\n    if (!snd.done)\r\n        throw new Error(\"Seq had multiple items\");\r\n    return fst.value;\r\n}\r\nexport function except(itemsToExclude, source) {\r\n    var exclusionItems = Array.from(itemsToExclude);\r\n    var testIsNotInExclusionItems = function (element) { return !exclusionItems.some(function (excludedItem) { return equals(excludedItem, element); }); };\r\n    return filter(testIsNotInExclusionItems, source);\r\n}\r\nexport function exists(f, xs) {\r\n    function aux(iter) {\r\n        var cur = iter.next();\r\n        return !cur.done && (f(cur.value) || aux(iter));\r\n    }\r\n    return aux(xs[Symbol.iterator]());\r\n}\r\nexport function exists2(f, xs, ys) {\r\n    function aux(iter1, iter2) {\r\n        var cur1 = iter1.next(), cur2 = iter2.next();\r\n        return !cur1.done && !cur2.done && (f(cur1.value, cur2.value) || aux(iter1, iter2));\r\n    }\r\n    return aux(xs[Symbol.iterator](), ys[Symbol.iterator]());\r\n}\r\nexport function filter(f, xs) {\r\n    function trySkipToNext(iter) {\r\n        var cur = iter.next();\r\n        while (!cur.done) {\r\n            if (f(cur.value)) {\r\n                return [cur.value, iter];\r\n            }\r\n            cur = iter.next();\r\n        }\r\n        return void 0;\r\n    }\r\n    return delay(function () { return unfold(trySkipToNext, xs[Symbol.iterator]()); });\r\n}\r\nexport function where(f, xs) {\r\n    return filter(f, xs);\r\n}\r\nexport function fold(f, acc, xs) {\r\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {\r\n        return xs.reduce(f, acc);\r\n    }\r\n    else {\r\n        var cur = void 0;\r\n        for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n            cur = iter.next();\r\n            if (cur.done)\r\n                break;\r\n            acc = f(acc, cur.value, i);\r\n        }\r\n        return acc;\r\n    }\r\n}\r\nexport function foldBack(f, xs, acc) {\r\n    var arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\r\n    for (var i = arr.length - 1; i >= 0; i--) {\r\n        acc = f(arr[i], acc, i);\r\n    }\r\n    return acc;\r\n}\r\nexport function fold2(f, acc, xs, ys) {\r\n    var iter1 = xs[Symbol.iterator](), iter2 = ys[Symbol.iterator]();\r\n    var cur1, cur2;\r\n    for (var i = 0;; i++) {\r\n        cur1 = iter1.next();\r\n        cur2 = iter2.next();\r\n        if (cur1.done || cur2.done) {\r\n            break;\r\n        }\r\n        acc = f(acc, cur1.value, cur2.value, i);\r\n    }\r\n    return acc;\r\n}\r\nexport function foldBack2(f, xs, ys, acc) {\r\n    var ar1 = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\r\n    var ar2 = Array.isArray(ys) || ArrayBuffer.isView(ys) ? ys : Array.from(ys);\r\n    for (var i = ar1.length - 1; i >= 0; i--) {\r\n        acc = f(ar1[i], ar2[i], acc, i);\r\n    }\r\n    return acc;\r\n}\r\nexport function forAll(f, xs) {\r\n    return fold(function (acc, x) { return acc && f(x); }, true, xs);\r\n}\r\nexport function forAll2(f, xs, ys) {\r\n    return fold2(function (acc, x, y) { return acc && f(x, y); }, true, xs, ys);\r\n}\r\nexport function tryHead(xs) {\r\n    var iter = xs[Symbol.iterator]();\r\n    var cur = iter.next();\r\n    return cur.done ? null : cur.value;\r\n}\r\nexport function head(xs) {\r\n    return __failIfNone(tryHead(xs));\r\n}\r\nexport function initialize(n, f) {\r\n    return delay(function () {\r\n        return unfold(function (i) { return i < n ? [f(i), i + 1] : null; }, 0);\r\n    });\r\n}\r\nexport function initializeInfinite(f) {\r\n    return delay(function () {\r\n        return unfold(function (i) { return [f(i), i + 1]; }, 0);\r\n    });\r\n}\r\nexport function tryItem(i, xs) {\r\n    if (i < 0)\r\n        return null;\r\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs))\r\n        return i < xs.length ? xs[i] : null;\r\n    for (var j = 0, iter = xs[Symbol.iterator]();; j++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            return null;\r\n        if (j === i)\r\n            return cur.value;\r\n    }\r\n}\r\nexport function item(i, xs) {\r\n    return __failIfNone(tryItem(i, xs));\r\n}\r\nexport function iterate(f, xs) {\r\n    fold(function (_, x) { return f(x); }, null, xs);\r\n}\r\nexport function iterate2(f, xs, ys) {\r\n    fold2(function (_, x, y) { return f(x, y); }, null, xs, ys);\r\n}\r\nexport function iterateIndexed(f, xs) {\r\n    fold(function (_, x, i) { return f(i, x); }, null, xs);\r\n}\r\nexport function iterateIndexed2(f, xs, ys) {\r\n    fold2(function (_, x, y, i) { return f(i, x, y); }, null, xs, ys);\r\n}\r\nexport function isEmpty(xs) {\r\n    var i = xs[Symbol.iterator]();\r\n    return i.next().done;\r\n}\r\nexport function tryLast(xs) {\r\n    try {\r\n        return reduce(function (_, x) { return x; }, xs);\r\n    }\r\n    catch (err) {\r\n        return null;\r\n    }\r\n}\r\nexport function last(xs) {\r\n    return __failIfNone(tryLast(xs));\r\n}\r\nexport function count(xs) {\r\n    return Array.isArray(xs) || ArrayBuffer.isView(xs)\r\n        ? xs.length\r\n        : fold(function (acc, x) { return acc + 1; }, 0, xs);\r\n}\r\nexport function map(f, xs) {\r\n    return delay(function () { return unfold(function (iter) {\r\n        var cur = iter.next();\r\n        return !cur.done ? [f(cur.value), iter] : null;\r\n    }, xs[Symbol.iterator]()); });\r\n}\r\nexport function mapIndexed(f, xs) {\r\n    return delay(function () {\r\n        var i = 0;\r\n        return unfold(function (iter) {\r\n            var cur = iter.next();\r\n            return !cur.done ? [f(i++, cur.value), iter] : null;\r\n        }, xs[Symbol.iterator]());\r\n    });\r\n}\r\nexport function map2(f, xs, ys) {\r\n    return delay(function () {\r\n        var iter1 = xs[Symbol.iterator]();\r\n        var iter2 = ys[Symbol.iterator]();\r\n        return unfold(function () {\r\n            var cur1 = iter1.next(), cur2 = iter2.next();\r\n            return !cur1.done && !cur2.done ? [f(cur1.value, cur2.value), null] : null;\r\n        });\r\n    });\r\n}\r\nexport function mapIndexed2(f, xs, ys) {\r\n    return delay(function () {\r\n        var i = 0;\r\n        var iter1 = xs[Symbol.iterator]();\r\n        var iter2 = ys[Symbol.iterator]();\r\n        return unfold(function () {\r\n            var cur1 = iter1.next(), cur2 = iter2.next();\r\n            return !cur1.done && !cur2.done ? [f(i++, cur1.value, cur2.value), null] : null;\r\n        });\r\n    });\r\n}\r\nexport function map3(f, xs, ys, zs) {\r\n    return delay(function () {\r\n        var iter1 = xs[Symbol.iterator]();\r\n        var iter2 = ys[Symbol.iterator]();\r\n        var iter3 = zs[Symbol.iterator]();\r\n        return unfold(function () {\r\n            var cur1 = iter1.next(), cur2 = iter2.next(), cur3 = iter3.next();\r\n            return !cur1.done && !cur2.done && !cur3.done ? [f(cur1.value, cur2.value, cur3.value), null] : null;\r\n        });\r\n    });\r\n}\r\nexport function mapFold(f, acc, xs) {\r\n    var result = [];\r\n    var r;\r\n    var cur;\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        cur = iter.next();\r\n        if (cur.done)\r\n            break;\r\n        _a = f(acc, cur.value), r = _a[0], acc = _a[1];\r\n        result.push(r);\r\n    }\r\n    return [result, acc];\r\n    var _a;\r\n}\r\nexport function mapFoldBack(f, xs, acc) {\r\n    var arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\r\n    var result = [];\r\n    var r;\r\n    for (var i = arr.length - 1; i >= 0; i--) {\r\n        _a = f(arr[i], acc), r = _a[0], acc = _a[1];\r\n        result.push(r);\r\n    }\r\n    return [result, acc];\r\n    var _a;\r\n}\r\nexport function max(xs) {\r\n    return reduce(function (acc, x) { return compare(acc, x) === 1 ? acc : x; }, xs);\r\n}\r\nexport function maxBy(f, xs) {\r\n    return reduce(function (acc, x) { return compare(f(acc), f(x)) === 1 ? acc : x; }, xs);\r\n}\r\nexport function min(xs) {\r\n    return reduce(function (acc, x) { return compare(acc, x) === -1 ? acc : x; }, xs);\r\n}\r\nexport function minBy(f, xs) {\r\n    return reduce(function (acc, x) { return compare(f(acc), f(x)) === -1 ? acc : x; }, xs);\r\n}\r\nexport function pairwise(xs) {\r\n    return skip(2, scan(function (last, next) { return [last[1], next]; }, [0, 0], xs));\r\n}\r\nexport function permute(f, xs) {\r\n    return ofArray(arrayPermute(f, Array.from(xs)));\r\n}\r\nexport function rangeStep(first, step, last) {\r\n    if (step === 0)\r\n        throw new Error(\"Step cannot be 0\");\r\n    return delay(function () { return unfold(function (x) { return step > 0 && x <= last || step < 0 && x >= last ? [x, x + step] : null; }, first); });\r\n}\r\nexport function rangeChar(first, last) {\r\n    return delay(function () { return unfold(function (x) { return x <= last ? [x, String.fromCharCode(x.charCodeAt(0) + 1)] : null; }, first); });\r\n}\r\nexport function range(first, last) {\r\n    return rangeStep(first, 1, last);\r\n}\r\nexport function readOnly(xs) {\r\n    return map(function (x) { return x; }, xs);\r\n}\r\nexport function reduce(f, xs) {\r\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs))\r\n        return xs.reduce(f);\r\n    var iter = xs[Symbol.iterator]();\r\n    var cur = iter.next();\r\n    if (cur.done)\r\n        throw new Error(\"Seq was empty\");\r\n    var acc = cur.value;\r\n    for (;;) {\r\n        cur = iter.next();\r\n        if (cur.done)\r\n            break;\r\n        acc = f(acc, cur.value);\r\n    }\r\n    return acc;\r\n}\r\nexport function reduceBack(f, xs) {\r\n    var ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\r\n    if (ar.length === 0)\r\n        throw new Error(\"Seq was empty\");\r\n    var acc = ar[ar.length - 1];\r\n    for (var i = ar.length - 2; i >= 0; i--)\r\n        acc = f(ar[i], acc, i);\r\n    return acc;\r\n}\r\nexport function replicate(n, x) {\r\n    return initialize(n, function () { return x; });\r\n}\r\nexport function reverse(xs) {\r\n    var ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.slice(0) : Array.from(xs);\r\n    return ofArray(ar.reverse());\r\n}\r\nexport function scan(f, seed, xs) {\r\n    return delay(function () {\r\n        var iter = xs[Symbol.iterator]();\r\n        return unfold(function (acc) {\r\n            if (acc == null)\r\n                return [seed, seed];\r\n            var cur = iter.next();\r\n            if (!cur.done) {\r\n                acc = f(acc, cur.value);\r\n                return [acc, acc];\r\n            }\r\n            return void 0;\r\n        }, null);\r\n    });\r\n}\r\nexport function scanBack(f, xs, seed) {\r\n    return reverse(scan(function (acc, x) { return f(x, acc); }, seed, reverse(xs)));\r\n}\r\nexport function singleton(x) {\r\n    return unfold(function (x) { return x != null ? [x, null] : null; }, x);\r\n}\r\nexport function skip(n, xs) {\r\n    return _a = {},\r\n        _a[Symbol.iterator] = function () {\r\n            var iter = xs[Symbol.iterator]();\r\n            for (var i = 1; i <= n; i++)\r\n                if (iter.next().done)\r\n                    throw new Error(\"Seq has not enough elements\");\r\n            return iter;\r\n        },\r\n        _a;\r\n    var _a;\r\n}\r\nexport function skipWhile(f, xs) {\r\n    return delay(function () {\r\n        var hasPassed = false;\r\n        return filter(function (x) { return hasPassed || (hasPassed = !f(x)); }, xs);\r\n    });\r\n}\r\nexport function sortWith(f, xs) {\r\n    var ys = Array.from(xs);\r\n    return ofArray(ys.sort(f));\r\n}\r\nexport function sum(xs) {\r\n    return fold(function (acc, x) { return acc + x; }, 0, xs);\r\n}\r\nexport function sumBy(f, xs) {\r\n    return fold(function (acc, x) { return acc + f(x); }, 0, xs);\r\n}\r\nexport function tail(xs) {\r\n    var iter = xs[Symbol.iterator]();\r\n    var cur = iter.next();\r\n    if (cur.done)\r\n        throw new Error(\"Seq was empty\");\r\n    return _a = {},\r\n        _a[Symbol.iterator] = function () { return iter; },\r\n        _a;\r\n    var _a;\r\n}\r\nexport function take(n, xs, truncate) {\r\n    if (truncate === void 0) { truncate = false; }\r\n    return delay(function () {\r\n        var iter = xs[Symbol.iterator]();\r\n        return unfold(function (i) {\r\n            if (i < n) {\r\n                var cur = iter.next();\r\n                if (!cur.done)\r\n                    return [cur.value, i + 1];\r\n                if (!truncate)\r\n                    throw new Error(\"Seq has not enough elements\");\r\n            }\r\n            return void 0;\r\n        }, 0);\r\n    });\r\n}\r\nexport function truncate(n, xs) {\r\n    return take(n, xs, true);\r\n}\r\nexport function takeWhile(f, xs) {\r\n    return delay(function () {\r\n        var iter = xs[Symbol.iterator]();\r\n        return unfold(function (i) {\r\n            var cur = iter.next();\r\n            if (!cur.done && f(cur.value))\r\n                return [cur.value, null];\r\n            return void 0;\r\n        }, 0);\r\n    });\r\n}\r\nexport function tryFind(f, xs, defaultValue) {\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            return defaultValue === void 0 ? null : defaultValue;\r\n        if (f(cur.value, i))\r\n            return cur.value;\r\n    }\r\n}\r\nexport function find(f, xs) {\r\n    return __failIfNone(tryFind(f, xs));\r\n}\r\nexport function tryFindBack(f, xs, defaultValue) {\r\n    var match = null;\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            return match === null ? (defaultValue === void 0 ? null : defaultValue) : match;\r\n        if (f(cur.value, i))\r\n            match = cur.value;\r\n    }\r\n}\r\nexport function findBack(f, xs) {\r\n    return __failIfNone(tryFindBack(f, xs));\r\n}\r\nexport function tryFindIndex(f, xs) {\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            return null;\r\n        if (f(cur.value, i))\r\n            return i;\r\n    }\r\n}\r\nexport function findIndex(f, xs) {\r\n    return __failIfNone(tryFindIndex(f, xs));\r\n}\r\nexport function tryFindIndexBack(f, xs) {\r\n    var match = -1;\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            return match === -1 ? null : match;\r\n        if (f(cur.value, i))\r\n            match = i;\r\n    }\r\n}\r\nexport function findIndexBack(f, xs) {\r\n    return __failIfNone(tryFindIndexBack(f, xs));\r\n}\r\nexport function tryPick(f, xs) {\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            break;\r\n        var y = f(cur.value, i);\r\n        if (y != null)\r\n            return y;\r\n    }\r\n    return void 0;\r\n}\r\nexport function pick(f, xs) {\r\n    return __failIfNone(tryPick(f, xs));\r\n}\r\nexport function unfold(f, acc) {\r\n    return _a = {},\r\n        _a[Symbol.iterator] = function () {\r\n            return {\r\n                next: function () {\r\n                    var res = f(acc);\r\n                    if (res != null) {\r\n                        acc = res[1];\r\n                        return { done: false, value: res[0] };\r\n                    }\r\n                    return { done: true };\r\n                }\r\n            };\r\n        },\r\n        _a;\r\n    var _a;\r\n}\r\nexport function zip(xs, ys) {\r\n    return map2(function (x, y) { return [x, y]; }, xs, ys);\r\n}\r\nexport function zip3(xs, ys, zs) {\r\n    return map3(function (x, y, z) { return [x, y, z]; }, xs, ys, zs);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/Seq.js\n// module id = 1\n// module chunks = 0","var fableGlobal = function () {\r\n    var globalObj = typeof window !== \"undefined\" ? window\r\n        : (typeof global !== \"undefined\" ? global\r\n            : (typeof self !== \"undefined\" ? self : {}));\r\n    if (typeof globalObj.__FABLE_CORE__ === \"undefined\") {\r\n        globalObj.__FABLE_CORE__ = {\r\n            types: new Map(),\r\n            symbols: {\r\n                reflection: Symbol(\"reflection\"),\r\n            }\r\n        };\r\n    }\r\n    return globalObj.__FABLE_CORE__;\r\n}();\r\nexport function setType(fullName, cons) {\r\n    fableGlobal.types.set(fullName, cons);\r\n}\r\nexport function getType(fullName) {\r\n    return fableGlobal.types.get(fullName);\r\n}\r\nexport default (fableGlobal.symbols);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/Symbol.js\n// module id = 2\n// module chunks = 0","import { create as timeSpanCreate } from \"./TimeSpan\";\r\nimport { compare as utilCompare } from \"./Util\";\r\nimport * as Long from \"./Long\";\r\nexport function minValue() {\r\n    return parse(-8640000000000000, 1);\r\n}\r\nexport function maxValue() {\r\n    return parse(8640000000000000, 1);\r\n}\r\nexport function parse(v, kind) {\r\n    if (kind == null) {\r\n        kind = typeof v == \"string\" && v.slice(-1) == \"Z\" ? 1 : 2;\r\n    }\r\n    var date = (v == null) ? new Date() : new Date(v);\r\n    if (kind === 2) {\r\n        date.kind = kind;\r\n    }\r\n    if (isNaN(date.getTime())) {\r\n        throw new Error(\"The string is not a valid Date.\");\r\n    }\r\n    return date;\r\n}\r\nexport function tryParse(v) {\r\n    try {\r\n        return [true, parse(v)];\r\n    }\r\n    catch (_err) {\r\n        return [false, minValue()];\r\n    }\r\n}\r\nexport function create(year, month, day, h, m, s, ms, kind) {\r\n    if (h === void 0) { h = 0; }\r\n    if (m === void 0) { m = 0; }\r\n    if (s === void 0) { s = 0; }\r\n    if (ms === void 0) { ms = 0; }\r\n    if (kind === void 0) { kind = 2; }\r\n    var date;\r\n    if (kind === 2) {\r\n        date = new Date(year, month - 1, day, h, m, s, ms);\r\n        date.kind = kind;\r\n    }\r\n    else {\r\n        date = new Date(Date.UTC(year, month - 1, day, h, m, s, ms));\r\n    }\r\n    if (isNaN(date.getTime())) {\r\n        throw new Error(\"The parameters describe an unrepresentable Date.\");\r\n    }\r\n    return date;\r\n}\r\nexport function now() {\r\n    return parse();\r\n}\r\nexport function utcNow() {\r\n    return parse(null, 1);\r\n}\r\nexport function today() {\r\n    return date(now());\r\n}\r\nexport function isLeapYear(year) {\r\n    return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\r\n}\r\nexport function daysInMonth(year, month) {\r\n    return month == 2\r\n        ? isLeapYear(year) ? 29 : 28\r\n        : month >= 8 ? month % 2 == 0 ? 31 : 30 : month % 2 == 0 ? 30 : 31;\r\n}\r\nexport function toUniversalTime(d) {\r\n    return d.kind === 2 ? new Date(d.getTime()) : d;\r\n}\r\nexport function toLocalTime(d) {\r\n    if (d.kind === 2) {\r\n        return d;\r\n    }\r\n    else {\r\n        var d2 = new Date(d.getTime());\r\n        d2.kind = 2;\r\n        return d2;\r\n    }\r\n}\r\nexport function timeOfDay(d) {\r\n    return timeSpanCreate(0, hour(d), minute(d), second(d), millisecond(d));\r\n}\r\nexport function date(d) {\r\n    return create(year(d), month(d), day(d), 0, 0, 0, 0, d.kind || 1);\r\n}\r\nexport function kind(d) {\r\n    return d.kind || 1;\r\n}\r\nexport function day(d) {\r\n    return d.kind === 2 ? d.getDate() : d.getUTCDate();\r\n}\r\nexport function hour(d) {\r\n    return d.kind === 2 ? d.getHours() : d.getUTCHours();\r\n}\r\nexport function millisecond(d) {\r\n    return d.kind === 2 ? d.getMilliseconds() : d.getUTCMilliseconds();\r\n}\r\nexport function minute(d) {\r\n    return d.kind === 2 ? d.getMinutes() : d.getUTCMinutes();\r\n}\r\nexport function month(d) {\r\n    return (d.kind === 2 ? d.getMonth() : d.getUTCMonth()) + 1;\r\n}\r\nexport function second(d) {\r\n    return d.kind === 2 ? d.getSeconds() : d.getUTCSeconds();\r\n}\r\nexport function year(d) {\r\n    return d.kind === 2 ? d.getFullYear() : d.getUTCFullYear();\r\n}\r\nexport function dayOfWeek(d) {\r\n    return d.kind === 2 ? d.getDay() : d.getUTCDay();\r\n}\r\nexport function ticks(d) {\r\n    return Long.fromNumber(d.getTime())\r\n        .add(62135596800000)\r\n        .sub(d.kind == 2 ? d.getTimezoneOffset() * 60 * 1000 : 0)\r\n        .mul(10000);\r\n}\r\nexport function toBinary(d) {\r\n    return ticks(d);\r\n}\r\nexport function dayOfYear(d) {\r\n    var _year = year(d);\r\n    var _month = month(d);\r\n    var _day = day(d);\r\n    for (var i = 1; i < _month; i++)\r\n        _day += daysInMonth(_year, i);\r\n    return _day;\r\n}\r\nexport function add(d, ts) {\r\n    return parse(d.getTime() + ts, d.kind || 1);\r\n}\r\nexport function addDays(d, v) {\r\n    return parse(d.getTime() + v * 86400000, d.kind || 1);\r\n}\r\nexport function addHours(d, v) {\r\n    return parse(d.getTime() + v * 3600000, d.kind || 1);\r\n}\r\nexport function addMinutes(d, v) {\r\n    return parse(d.getTime() + v * 60000, d.kind || 1);\r\n}\r\nexport function addSeconds(d, v) {\r\n    return parse(d.getTime() + v * 1000, d.kind || 1);\r\n}\r\nexport function addMilliseconds(d, v) {\r\n    return parse(d.getTime() + v, d.kind || 1);\r\n}\r\nexport function addTicks(d, t) {\r\n    return parse(Long.fromNumber(d.getTime()).add(t.div(10000)).toNumber(), d.kind || 1);\r\n}\r\nexport function addYears(d, v) {\r\n    var newMonth = month(d);\r\n    var newYear = year(d) + v;\r\n    var _daysInMonth = daysInMonth(newYear, newMonth);\r\n    var newDay = Math.min(_daysInMonth, day(d));\r\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind || 1);\r\n}\r\nexport function addMonths(d, v) {\r\n    var newMonth = month(d) + v;\r\n    var newMonth_ = 0;\r\n    var yearOffset = 0;\r\n    if (newMonth > 12) {\r\n        newMonth_ = newMonth % 12;\r\n        yearOffset = Math.floor(newMonth / 12);\r\n        newMonth = newMonth_;\r\n    }\r\n    else if (newMonth < 1) {\r\n        newMonth_ = 12 + newMonth % 12;\r\n        yearOffset = Math.floor(newMonth / 12) + (newMonth_ == 12 ? -1 : 0);\r\n        newMonth = newMonth_;\r\n    }\r\n    var newYear = year(d) + yearOffset;\r\n    var _daysInMonth = daysInMonth(newYear, newMonth);\r\n    var newDay = Math.min(_daysInMonth, day(d));\r\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind || 1);\r\n}\r\nexport function subtract(d, that) {\r\n    return typeof that == \"number\"\r\n        ? parse(d.getTime() - that, d.kind || 1)\r\n        : d.getTime() - that.getTime();\r\n}\r\nexport function toLongDateString(d) {\r\n    return d.toDateString();\r\n}\r\nexport function toShortDateString(d) {\r\n    return d.toLocaleDateString();\r\n}\r\nexport function toLongTimeString(d) {\r\n    return d.toLocaleTimeString();\r\n}\r\nexport function toShortTimeString(d) {\r\n    return d.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\r\n}\r\nexport function equals(d1, d2) {\r\n    return d1.getTime() == d2.getTime();\r\n}\r\nexport function compare(x, y) {\r\n    return utilCompare(x, y);\r\n}\r\nexport function compareTo(x, y) {\r\n    return utilCompare(x, y);\r\n}\r\nexport function op_Addition(x, y) {\r\n    return add(x, y);\r\n}\r\nexport function op_Subtraction(x, y) {\r\n    return subtract(x, y);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/Date.js\n// module id = 3\n// module chunks = 0","import List from \"./ListClass\";\r\nimport { map as seqMap } from \"./Seq\";\r\nimport { fold as seqFold } from \"./Seq\";\r\nimport { foldBack as seqFoldBack } from \"./Seq\";\r\nimport { toList as seqToList } from \"./Seq\";\r\nimport { groupBy as mapGroupBy } from \"./Map\";\r\nexport default List;\r\nexport { ofArray } from \"./ListClass\";\r\nexport function append(xs, ys) {\r\n    return seqFold(function (acc, x) { return new List(x, acc); }, ys, reverse(xs));\r\n}\r\nexport function choose(f, xs) {\r\n    var r = seqFold(function (acc, x) {\r\n        var y = f(x);\r\n        return y != null ? new List(y, acc) : acc;\r\n    }, new List(), xs);\r\n    return reverse(r);\r\n}\r\nexport function collect(f, xs) {\r\n    return seqFold(function (acc, x) { return append(acc, f(x)); }, new List(), xs);\r\n}\r\nexport function concat(xs) {\r\n    return collect(function (x) { return x; }, xs);\r\n}\r\nexport function filter(f, xs) {\r\n    return reverse(seqFold(function (acc, x) { return f(x) ? new List(x, acc) : acc; }, new List(), xs));\r\n}\r\nexport function where(f, xs) {\r\n    return filter(f, xs);\r\n}\r\nexport function initialize(n, f) {\r\n    if (n < 0) {\r\n        throw new Error(\"List length must be non-negative\");\r\n    }\r\n    var xs = new List();\r\n    for (var i = 1; i <= n; i++) {\r\n        xs = new List(f(n - i), xs);\r\n    }\r\n    return xs;\r\n}\r\nexport function map(f, xs) {\r\n    return reverse(seqFold(function (acc, x) { return new List(f(x), acc); }, new List(), xs));\r\n}\r\nexport function mapIndexed(f, xs) {\r\n    return reverse(seqFold(function (acc, x, i) { return new List(f(i, x), acc); }, new List(), xs));\r\n}\r\nexport function partition(f, xs) {\r\n    return seqFold(function (acc, x) {\r\n        var lacc = acc[0], racc = acc[1];\r\n        return f(x) ? [new List(x, lacc), racc] : [lacc, new List(x, racc)];\r\n    }, [new List(), new List()], reverse(xs));\r\n}\r\nexport function replicate(n, x) {\r\n    return initialize(n, function () { return x; });\r\n}\r\nexport function reverse(xs) {\r\n    return seqFold(function (acc, x) { return new List(x, acc); }, new List(), xs);\r\n}\r\nexport function singleton(x) {\r\n    return new List(x, new List());\r\n}\r\nexport function slice(lower, upper, xs) {\r\n    var noLower = (lower == null);\r\n    var noUpper = (upper == null);\r\n    return reverse(seqFold(function (acc, x, i) { return (noLower || lower <= i) && (noUpper || i <= upper) ? new List(x, acc) : acc; }, new List(), xs));\r\n}\r\nexport function unzip(xs) {\r\n    return seqFoldBack(function (xy, acc) {\r\n        return [new List(xy[0], acc[0]), new List(xy[1], acc[1])];\r\n    }, xs, [new List(), new List()]);\r\n}\r\nexport function unzip3(xs) {\r\n    return seqFoldBack(function (xyz, acc) {\r\n        return [new List(xyz[0], acc[0]), new List(xyz[1], acc[1]), new List(xyz[2], acc[2])];\r\n    }, xs, [new List(), new List(), new List()]);\r\n}\r\nexport function groupBy(f, xs) {\r\n    return seqToList(seqMap(function (k) { return [k[0], seqToList(k[1])]; }, mapGroupBy(f, xs)));\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/List.js\n// module id = 4\n// module chunks = 0","import FSymbol from \"./Symbol\";\r\nimport { toString } from \"./Util\";\r\nimport { equals } from \"./Util\";\r\nimport { compare } from \"./Util\";\r\nexport function ofArray(args, base) {\r\n    var acc = base || new List();\r\n    for (var i = args.length - 1; i >= 0; i--) {\r\n        acc = new List(args[i], acc);\r\n    }\r\n    return acc;\r\n}\r\nvar List = (function () {\r\n    function List(head, tail) {\r\n        this.head = head;\r\n        this.tail = tail;\r\n    }\r\n    List.prototype.ToString = function () {\r\n        return \"[\" + Array.from(this).map(toString).join(\"; \") + \"]\";\r\n    };\r\n    List.prototype.Equals = function (x) {\r\n        if (this === x) {\r\n            return true;\r\n        }\r\n        else {\r\n            var iter1 = this[Symbol.iterator](), iter2 = x[Symbol.iterator]();\r\n            for (;;) {\r\n                var cur1 = iter1.next(), cur2 = iter2.next();\r\n                if (cur1.done)\r\n                    return cur2.done ? true : false;\r\n                else if (cur2.done)\r\n                    return false;\r\n                else if (!equals(cur1.value, cur2.value))\r\n                    return false;\r\n            }\r\n        }\r\n    };\r\n    List.prototype.CompareTo = function (x) {\r\n        if (this === x) {\r\n            return 0;\r\n        }\r\n        else {\r\n            var acc = 0;\r\n            var iter1 = this[Symbol.iterator](), iter2 = x[Symbol.iterator]();\r\n            for (;;) {\r\n                var cur1 = iter1.next(), cur2 = iter2.next();\r\n                if (cur1.done)\r\n                    return cur2.done ? acc : -1;\r\n                else if (cur2.done)\r\n                    return 1;\r\n                else {\r\n                    acc = compare(cur1.value, cur2.value);\r\n                    if (acc != 0)\r\n                        return acc;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Object.defineProperty(List.prototype, \"length\", {\r\n        get: function () {\r\n            var cur = this, acc = 0;\r\n            while (cur.tail != null) {\r\n                cur = cur.tail;\r\n                acc++;\r\n            }\r\n            return acc;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    List.prototype[Symbol.iterator] = function () {\r\n        var cur = this;\r\n        return {\r\n            next: function () {\r\n                var tmp = cur;\r\n                cur = cur.tail;\r\n                return { done: tmp.tail == null, value: tmp.head };\r\n            }\r\n        };\r\n    };\r\n    List.prototype[FSymbol.reflection] = function () {\r\n        return {\r\n            type: \"Microsoft.FSharp.Collections.FSharpList\",\r\n            interfaces: [\"System.IEquatable\", \"System.IComparable\"]\r\n        };\r\n    };\r\n    return List;\r\n}());\r\nexport default List;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/ListClass.js\n// module id = 5\n// module chunks = 0","import List from \"./ListClass\";\r\nimport { ofArray as listOfArray } from \"./ListClass\";\r\nimport { toString } from \"./Util\";\r\nimport { equals } from \"./Util\";\r\nimport { compare } from \"./Util\";\r\nimport GenericComparer from \"./GenericComparer\";\r\nimport FSymbol from \"./Symbol\";\r\nimport { map as seqMap } from \"./Seq\";\r\nimport { fold as seqFold } from \"./Seq\";\r\nimport { pick as seqPick } from \"./Seq\";\r\nimport { tryPick as seqTryPick } from \"./Seq\";\r\nimport { compareWith as seqCompareWith } from \"./Seq\";\r\nexport function groupBy(f, xs) {\r\n    var keys = [], iter = xs[Symbol.iterator]();\r\n    var acc = create(), cur = iter.next();\r\n    while (!cur.done) {\r\n        var k = f(cur.value), vs = tryFind(k, acc);\r\n        if (vs == null) {\r\n            keys.push(k);\r\n            acc = add(k, [cur.value], acc);\r\n        }\r\n        else {\r\n            vs.push(cur.value);\r\n        }\r\n        cur = iter.next();\r\n    }\r\n    return keys.map(function (k) { return [k, acc.get(k)]; });\r\n}\r\nexport function countBy(f, xs) {\r\n    return groupBy(f, xs).map(function (kv) { return [kv[0], kv[1].length]; });\r\n}\r\nvar MapTree = (function () {\r\n    function MapTree(caseName, fields) {\r\n        this.Case = caseName;\r\n        this.Fields = fields;\r\n    }\r\n    return MapTree;\r\n}());\r\nexport { MapTree };\r\nfunction tree_sizeAux(acc, m) {\r\n    return m.Case === \"MapOne\"\r\n        ? acc + 1\r\n        : m.Case === \"MapNode\"\r\n            ? tree_sizeAux(tree_sizeAux(acc + 1, m.Fields[2]), m.Fields[3])\r\n            : acc;\r\n}\r\nfunction tree_size(x) {\r\n    return tree_sizeAux(0, x);\r\n}\r\nfunction tree_empty() {\r\n    return new MapTree(\"MapEmpty\", []);\r\n}\r\nfunction tree_height(_arg1) {\r\n    return _arg1.Case === \"MapOne\" ? 1 : _arg1.Case === \"MapNode\" ? _arg1.Fields[4] : 0;\r\n}\r\nfunction tree_isEmpty(m) {\r\n    return m.Case === \"MapEmpty\" ? true : false;\r\n}\r\nfunction tree_mk(l, k, v, r) {\r\n    var matchValue = [l, r];\r\n    var $target1 = function () {\r\n        var hl = tree_height(l);\r\n        var hr = tree_height(r);\r\n        var m = hl < hr ? hr : hl;\r\n        return new MapTree(\"MapNode\", [k, v, l, r, m + 1]);\r\n    };\r\n    if (matchValue[0].Case === \"MapEmpty\") {\r\n        if (matchValue[1].Case === \"MapEmpty\") {\r\n            return new MapTree(\"MapOne\", [k, v]);\r\n        }\r\n        else {\r\n            return $target1();\r\n        }\r\n    }\r\n    else {\r\n        return $target1();\r\n    }\r\n}\r\n;\r\nfunction tree_rebalance(t1, k, v, t2) {\r\n    var t1h = tree_height(t1);\r\n    var t2h = tree_height(t2);\r\n    if (t2h > t1h + 2) {\r\n        if (t2.Case === \"MapNode\") {\r\n            if (tree_height(t2.Fields[2]) > t1h + 1) {\r\n                if (t2.Fields[2].Case === \"MapNode\") {\r\n                    return tree_mk(tree_mk(t1, k, v, t2.Fields[2].Fields[2]), t2.Fields[2].Fields[0], t2.Fields[2].Fields[1], tree_mk(t2.Fields[2].Fields[3], t2.Fields[0], t2.Fields[1], t2.Fields[3]));\r\n                }\r\n                else {\r\n                    throw new Error(\"rebalance\");\r\n                }\r\n            }\r\n            else {\r\n                return tree_mk(tree_mk(t1, k, v, t2.Fields[2]), t2.Fields[0], t2.Fields[1], t2.Fields[3]);\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(\"rebalance\");\r\n        }\r\n    }\r\n    else {\r\n        if (t1h > t2h + 2) {\r\n            if (t1.Case === \"MapNode\") {\r\n                if (tree_height(t1.Fields[3]) > t2h + 1) {\r\n                    if (t1.Fields[3].Case === \"MapNode\") {\r\n                        return tree_mk(tree_mk(t1.Fields[2], t1.Fields[0], t1.Fields[1], t1.Fields[3].Fields[2]), t1.Fields[3].Fields[0], t1.Fields[3].Fields[1], tree_mk(t1.Fields[3].Fields[3], k, v, t2));\r\n                    }\r\n                    else {\r\n                        throw new Error(\"rebalance\");\r\n                    }\r\n                }\r\n                else {\r\n                    return tree_mk(t1.Fields[2], t1.Fields[0], t1.Fields[1], tree_mk(t1.Fields[3], k, v, t2));\r\n                }\r\n            }\r\n            else {\r\n                throw new Error(\"rebalance\");\r\n            }\r\n        }\r\n        else {\r\n            return tree_mk(t1, k, v, t2);\r\n        }\r\n    }\r\n}\r\nfunction tree_add(comparer, k, v, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c < 0) {\r\n            return new MapTree(\"MapNode\", [k, v, new MapTree(\"MapEmpty\", []), m, 2]);\r\n        }\r\n        else if (c === 0) {\r\n            return new MapTree(\"MapOne\", [k, v]);\r\n        }\r\n        return new MapTree(\"MapNode\", [k, v, m, new MapTree(\"MapEmpty\", []), 2]);\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_rebalance(tree_add(comparer, k, v, m.Fields[2]), m.Fields[0], m.Fields[1], m.Fields[3]);\r\n        }\r\n        else if (c === 0) {\r\n            return new MapTree(\"MapNode\", [k, v, m.Fields[2], m.Fields[3], m.Fields[4]]);\r\n        }\r\n        return tree_rebalance(m.Fields[2], m.Fields[0], m.Fields[1], tree_add(comparer, k, v, m.Fields[3]));\r\n    }\r\n    return new MapTree(\"MapOne\", [k, v]);\r\n}\r\nfunction tree_find(comparer, k, m) {\r\n    var res = tree_tryFind(comparer, k, m);\r\n    if (res != null)\r\n        return res;\r\n    throw new Error(\"key not found\");\r\n}\r\nfunction tree_tryFind(comparer, k, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        return c === 0 ? m.Fields[1] : null;\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_tryFind(comparer, k, m.Fields[2]);\r\n        }\r\n        else {\r\n            if (c === 0) {\r\n                return m.Fields[1];\r\n            }\r\n            else {\r\n                return tree_tryFind(comparer, k, m.Fields[3]);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction tree_partition1(comparer, f, k, v, acc1, acc2) {\r\n    return f(k, v) ? [tree_add(comparer, k, v, acc1), acc2] : [acc1, tree_add(comparer, k, v, acc2)];\r\n}\r\nfunction tree_partitionAux(comparer, f, s, acc_0, acc_1) {\r\n    var acc = [acc_0, acc_1];\r\n    if (s.Case === \"MapOne\") {\r\n        return tree_partition1(comparer, f, s.Fields[0], s.Fields[1], acc[0], acc[1]);\r\n    }\r\n    else if (s.Case === \"MapNode\") {\r\n        var acc_2 = tree_partitionAux(comparer, f, s.Fields[3], acc[0], acc[1]);\r\n        var acc_3 = tree_partition1(comparer, f, s.Fields[0], s.Fields[1], acc_2[0], acc_2[1]);\r\n        return tree_partitionAux(comparer, f, s.Fields[2], acc_3[0], acc_3[1]);\r\n    }\r\n    return acc;\r\n}\r\nfunction tree_partition(comparer, f, s) {\r\n    return tree_partitionAux(comparer, f, s, tree_empty(), tree_empty());\r\n}\r\nfunction tree_filter1(comparer, f, k, v, acc) {\r\n    return f(k, v) ? tree_add(comparer, k, v, acc) : acc;\r\n}\r\nfunction tree_filterAux(comparer, f, s, acc) {\r\n    return s.Case === \"MapOne\" ? tree_filter1(comparer, f, s.Fields[0], s.Fields[1], acc) : s.Case === \"MapNode\" ? tree_filterAux(comparer, f, s.Fields[3], tree_filter1(comparer, f, s.Fields[0], s.Fields[1], tree_filterAux(comparer, f, s.Fields[2], acc))) : acc;\r\n}\r\nfunction tree_filter(comparer, f, s) {\r\n    return tree_filterAux(comparer, f, s, tree_empty());\r\n}\r\nfunction tree_spliceOutSuccessor(m) {\r\n    if (m.Case === \"MapOne\") {\r\n        return [m.Fields[0], m.Fields[1], new MapTree(\"MapEmpty\", [])];\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        if (m.Fields[2].Case === \"MapEmpty\") {\r\n            return [m.Fields[0], m.Fields[1], m.Fields[3]];\r\n        }\r\n        else {\r\n            var kvl = tree_spliceOutSuccessor(m.Fields[2]);\r\n            return [kvl[0], kvl[1], tree_mk(kvl[2], m.Fields[0], m.Fields[1], m.Fields[3])];\r\n        }\r\n    }\r\n    throw new Error(\"internal error: Map.spliceOutSuccessor\");\r\n}\r\nfunction tree_remove(comparer, k, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c === 0) {\r\n            return new MapTree(\"MapEmpty\", []);\r\n        }\r\n        else {\r\n            return m;\r\n        }\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_rebalance(tree_remove(comparer, k, m.Fields[2]), m.Fields[0], m.Fields[1], m.Fields[3]);\r\n        }\r\n        else {\r\n            if (c === 0) {\r\n                var matchValue = [m.Fields[2], m.Fields[3]];\r\n                if (matchValue[0].Case === \"MapEmpty\") {\r\n                    return m.Fields[3];\r\n                }\r\n                else {\r\n                    if (matchValue[1].Case === \"MapEmpty\") {\r\n                        return m.Fields[2];\r\n                    }\r\n                    else {\r\n                        var patternInput = tree_spliceOutSuccessor(m.Fields[3]);\r\n                        var sv = patternInput[1];\r\n                        var sk = patternInput[0];\r\n                        var r_ = patternInput[2];\r\n                        return tree_mk(m.Fields[2], sk, sv, r_);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                return tree_rebalance(m.Fields[2], m.Fields[0], m.Fields[1], tree_remove(comparer, k, m.Fields[3]));\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        return tree_empty();\r\n    }\r\n}\r\nfunction tree_mem(comparer, k, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        return comparer.Compare(k, m.Fields[0]) === 0;\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_mem(comparer, k, m.Fields[2]);\r\n        }\r\n        else {\r\n            if (c === 0) {\r\n                return true;\r\n            }\r\n            else {\r\n                return tree_mem(comparer, k, m.Fields[3]);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nfunction tree_iter(f, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        f(m.Fields[0], m.Fields[1]);\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        tree_iter(f, m.Fields[2]);\r\n        f(m.Fields[0], m.Fields[1]);\r\n        tree_iter(f, m.Fields[3]);\r\n    }\r\n}\r\nfunction tree_tryPick(f, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        return f(m.Fields[0], m.Fields[1]);\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        var matchValue = tree_tryPick(f, m.Fields[2]);\r\n        if (matchValue == null) {\r\n            var matchValue_1 = f(m.Fields[0], m.Fields[1]);\r\n            if (matchValue_1 == null) {\r\n                return tree_tryPick(f, m.Fields[3]);\r\n            }\r\n            else {\r\n                var res = matchValue_1;\r\n                return res;\r\n            }\r\n        }\r\n        else {\r\n            var res = matchValue;\r\n            return res;\r\n        }\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nfunction tree_exists(f, m) {\r\n    return m.Case === \"MapOne\" ? f(m.Fields[0], m.Fields[1]) : m.Case === \"MapNode\" ? (tree_exists(f, m.Fields[2]) ? true : f(m.Fields[0], m.Fields[1])) ? true : tree_exists(f, m.Fields[3]) : false;\r\n}\r\nfunction tree_forall(f, m) {\r\n    return m.Case === \"MapOne\" ? f(m.Fields[0], m.Fields[1]) : m.Case === \"MapNode\" ? (tree_forall(f, m.Fields[2]) ? f(m.Fields[0], m.Fields[1]) : false) ? tree_forall(f, m.Fields[3]) : false : true;\r\n}\r\nfunction tree_mapi(f, m) {\r\n    return m.Case === \"MapOne\" ? new MapTree(\"MapOne\", [m.Fields[0], f(m.Fields[0], m.Fields[1])]) : m.Case === \"MapNode\" ? new MapTree(\"MapNode\", [m.Fields[0], f(m.Fields[0], m.Fields[1]), tree_mapi(f, m.Fields[2]), tree_mapi(f, m.Fields[3]), m.Fields[4]]) : tree_empty();\r\n}\r\nfunction tree_foldBack(f, m, x) {\r\n    return m.Case === \"MapOne\" ? f(m.Fields[0], m.Fields[1], x) : m.Case === \"MapNode\" ? tree_foldBack(f, m.Fields[2], f(m.Fields[0], m.Fields[1], tree_foldBack(f, m.Fields[3], x))) : x;\r\n}\r\nfunction tree_fold(f, x, m) {\r\n    return m.Case === \"MapOne\" ? f(x, m.Fields[0], m.Fields[1]) : m.Case === \"MapNode\" ? tree_fold(f, f(tree_fold(f, x, m.Fields[2]), m.Fields[0], m.Fields[1]), m.Fields[3]) : x;\r\n}\r\nfunction tree_mkFromEnumerator(comparer, acc, e) {\r\n    var cur = e.next();\r\n    while (!cur.done) {\r\n        acc = tree_add(comparer, cur.value[0], cur.value[1], acc);\r\n        cur = e.next();\r\n    }\r\n    return acc;\r\n}\r\nfunction tree_ofSeq(comparer, c) {\r\n    var ie = c[Symbol.iterator]();\r\n    return tree_mkFromEnumerator(comparer, tree_empty(), ie);\r\n}\r\nfunction tree_collapseLHS(stack) {\r\n    if (stack.tail != null) {\r\n        if (stack.head.Case === \"MapOne\") {\r\n            return stack;\r\n        }\r\n        else if (stack.head.Case === \"MapNode\") {\r\n            return tree_collapseLHS(listOfArray([\r\n                stack.head.Fields[2],\r\n                new MapTree(\"MapOne\", [stack.head.Fields[0], stack.head.Fields[1]]),\r\n                stack.head.Fields[3]\r\n            ], stack.tail));\r\n        }\r\n        else {\r\n            return tree_collapseLHS(stack.tail);\r\n        }\r\n    }\r\n    else {\r\n        return new List();\r\n    }\r\n}\r\nfunction tree_mkIterator(s) {\r\n    return { stack: tree_collapseLHS(new List(s, new List())), started: false };\r\n}\r\nfunction tree_moveNext(i) {\r\n    function current(i) {\r\n        if (i.stack.tail == null) {\r\n            return null;\r\n        }\r\n        else if (i.stack.head.Case === \"MapOne\") {\r\n            return [i.stack.head.Fields[0], i.stack.head.Fields[1]];\r\n        }\r\n        throw new Error(\"Please report error: Map iterator, unexpected stack for current\");\r\n    }\r\n    if (i.started) {\r\n        if (i.stack.tail == null) {\r\n            return { done: true, value: null };\r\n        }\r\n        else {\r\n            if (i.stack.head.Case === \"MapOne\") {\r\n                i.stack = tree_collapseLHS(i.stack.tail);\r\n                return {\r\n                    done: i.stack.tail == null,\r\n                    value: current(i)\r\n                };\r\n            }\r\n            else {\r\n                throw new Error(\"Please report error: Map iterator, unexpected stack for moveNext\");\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        i.started = true;\r\n        return {\r\n            done: i.stack.tail == null,\r\n            value: current(i)\r\n        };\r\n    }\r\n    ;\r\n}\r\nvar FableMap = (function () {\r\n    function FableMap() {\r\n    }\r\n    FableMap.prototype.ToString = function () {\r\n        return \"map [\" + Array.from(this).map(toString).join(\"; \") + \"]\";\r\n    };\r\n    FableMap.prototype.Equals = function (m2) {\r\n        return this.CompareTo(m2) === 0;\r\n    };\r\n    FableMap.prototype.CompareTo = function (m2) {\r\n        var _this = this;\r\n        return this === m2 ? 0 : seqCompareWith(function (kvp1, kvp2) {\r\n            var c = _this.comparer.Compare(kvp1[0], kvp2[0]);\r\n            return c !== 0 ? c : compare(kvp1[1], kvp2[1]);\r\n        }, this, m2);\r\n    };\r\n    FableMap.prototype[Symbol.iterator] = function () {\r\n        var i = tree_mkIterator(this.tree);\r\n        return {\r\n            next: function () { return tree_moveNext(i); }\r\n        };\r\n    };\r\n    FableMap.prototype.entries = function () {\r\n        return this[Symbol.iterator]();\r\n    };\r\n    FableMap.prototype.keys = function () {\r\n        return seqMap(function (kv) { return kv[0]; }, this);\r\n    };\r\n    FableMap.prototype.values = function () {\r\n        return seqMap(function (kv) { return kv[1]; }, this);\r\n    };\r\n    FableMap.prototype.get = function (k) {\r\n        return tree_find(this.comparer, k, this.tree);\r\n    };\r\n    FableMap.prototype.has = function (k) {\r\n        return tree_mem(this.comparer, k, this.tree);\r\n    };\r\n    FableMap.prototype.set = function (k, v) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    FableMap.prototype.delete = function (k) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    FableMap.prototype.clear = function () {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    Object.defineProperty(FableMap.prototype, \"size\", {\r\n        get: function () {\r\n            return tree_size(this.tree);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FableMap.prototype[FSymbol.reflection] = function () {\r\n        return {\r\n            type: \"Microsoft.FSharp.Collections.FSharpMap\",\r\n            interfaces: [\"System.IEquatable\", \"System.IComparable\", \"System.Collections.Generic.IDictionary\"]\r\n        };\r\n    };\r\n    return FableMap;\r\n}());\r\nexport default FableMap;\r\nfunction from(comparer, tree) {\r\n    var map = new FableMap();\r\n    map.tree = tree;\r\n    map.comparer = comparer || new GenericComparer();\r\n    return map;\r\n}\r\nexport function create(ie, comparer) {\r\n    comparer = comparer || new GenericComparer();\r\n    return from(comparer, ie ? tree_ofSeq(comparer, ie) : tree_empty());\r\n}\r\nexport function add(k, v, map) {\r\n    return from(map.comparer, tree_add(map.comparer, k, v, map.tree));\r\n}\r\nexport function remove(item, map) {\r\n    return from(map.comparer, tree_remove(map.comparer, item, map.tree));\r\n}\r\nexport function containsValue(v, map) {\r\n    return seqFold(function (acc, k) { return acc || equals(map.get(k), v); }, false, map.keys());\r\n}\r\nexport function tryGetValue(map, key, defaultValue) {\r\n    return map.has(key) ? [true, map.get(key)] : [false, defaultValue];\r\n}\r\nexport function exists(f, map) {\r\n    return tree_exists(f, map.tree);\r\n}\r\nexport function find(k, map) {\r\n    return tree_find(map.comparer, k, map.tree);\r\n}\r\nexport function tryFind(k, map) {\r\n    return tree_tryFind(map.comparer, k, map.tree);\r\n}\r\nexport function filter(f, map) {\r\n    return from(map.comparer, tree_filter(map.comparer, f, map.tree));\r\n}\r\nexport function fold(f, seed, map) {\r\n    return tree_fold(f, seed, map.tree);\r\n}\r\nexport function foldBack(f, map, seed) {\r\n    return tree_foldBack(f, map.tree, seed);\r\n}\r\nexport function forAll(f, map) {\r\n    return tree_forall(f, map.tree);\r\n}\r\nexport function isEmpty(map) {\r\n    return tree_isEmpty(map.tree);\r\n}\r\nexport function iterate(f, map) {\r\n    tree_iter(f, map.tree);\r\n}\r\nexport function map(f, map) {\r\n    return from(map.comparer, tree_mapi(f, map.tree));\r\n}\r\nexport function partition(f, map) {\r\n    var rs = tree_partition(map.comparer, f, map.tree);\r\n    return [from(map.comparer, rs[0]), from(map.comparer, rs[1])];\r\n}\r\nexport function findKey(f, map) {\r\n    return seqPick(function (kv) { return f(kv[0], kv[1]) ? kv[0] : null; }, map);\r\n}\r\nexport function tryFindKey(f, map) {\r\n    return seqTryPick(function (kv) { return f(kv[0], kv[1]) ? kv[0] : null; }, map);\r\n}\r\nexport function pick(f, map) {\r\n    var res = tryPick(f, map);\r\n    if (res != null)\r\n        return res;\r\n    throw new Error(\"key not found\");\r\n}\r\nexport function tryPick(f, map) {\r\n    return tree_tryPick(f, map.tree);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/Map.js\n// module id = 6\n// module chunks = 0","import { compare } from \"./Util\";\r\nimport FSymbol from \"./Symbol\";\r\nvar GenericComparer = (function () {\r\n    function GenericComparer(f) {\r\n        this.Compare = f || compare;\r\n    }\r\n    GenericComparer.prototype[FSymbol.reflection] = function () {\r\n        return { interfaces: [\"System.IComparer\"] };\r\n    };\r\n    return GenericComparer;\r\n}());\r\nexport default GenericComparer;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/GenericComparer.js\n// module id = 7\n// module chunks = 0","import _Symbol from \"./Symbol\";\r\nvar Long = (function () {\r\n    function Long(low, high, unsigned) {\r\n        this.eq = this.equals;\r\n        this.neq = this.notEquals;\r\n        this.lt = this.lessThan;\r\n        this.lte = this.lessThanOrEqual;\r\n        this.gt = this.greaterThan;\r\n        this.gte = this.greaterThanOrEqual;\r\n        this.comp = this.compare;\r\n        this.neg = this.negate;\r\n        this.abs = this.absolute;\r\n        this.sub = this.subtract;\r\n        this.mul = this.multiply;\r\n        this.div = this.divide;\r\n        this.mod = this.modulo;\r\n        this.shl = this.shiftLeft;\r\n        this.shr = this.shiftRight;\r\n        this.shru = this.shiftRightUnsigned;\r\n        this.Equals = this.equals;\r\n        this.CompareTo = this.compare;\r\n        this.ToString = this.toString;\r\n        this.low = low | 0;\r\n        this.high = high | 0;\r\n        this.unsigned = !!unsigned;\r\n    }\r\n    Long.prototype.toInt = function () {\r\n        return this.unsigned ? this.low >>> 0 : this.low;\r\n    };\r\n    Long.prototype.toNumber = function () {\r\n        if (this.unsigned)\r\n            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n    };\r\n    Long.prototype.toString = function (radix) {\r\n        if (radix === void 0) { radix = 10; }\r\n        radix = radix || 10;\r\n        if (radix < 2 || 36 < radix)\r\n            throw RangeError('radix');\r\n        if (this.isZero())\r\n            return '0';\r\n        if (this.isNegative()) {\r\n            if (this.eq(MIN_VALUE)) {\r\n                var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\r\n                return div.toString(radix) + rem1.toInt().toString(radix);\r\n            }\r\n            else\r\n                return '-' + this.neg().toString(radix);\r\n        }\r\n        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;\r\n        var result = '';\r\n        while (true) {\r\n            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);\r\n            rem = remDiv;\r\n            if (rem.isZero())\r\n                return digits + result;\r\n            else {\r\n                while (digits.length < 6)\r\n                    digits = '0' + digits;\r\n                result = '' + digits + result;\r\n            }\r\n        }\r\n    };\r\n    Long.prototype.getHighBits = function () {\r\n        return this.high;\r\n    };\r\n    Long.prototype.getHighBitsUnsigned = function () {\r\n        return this.high >>> 0;\r\n    };\r\n    Long.prototype.getLowBits = function () {\r\n        return this.low;\r\n    };\r\n    Long.prototype.getLowBitsUnsigned = function () {\r\n        return this.low >>> 0;\r\n    };\r\n    Long.prototype.getNumBitsAbs = function () {\r\n        if (this.isNegative())\r\n            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n        var val = this.high != 0 ? this.high : this.low;\r\n        for (var bit = 31; bit > 0; bit--)\r\n            if ((val & (1 << bit)) != 0)\r\n                break;\r\n        return this.high != 0 ? bit + 33 : bit + 1;\r\n    };\r\n    Long.prototype.isZero = function () {\r\n        return this.high === 0 && this.low === 0;\r\n    };\r\n    Long.prototype.isNegative = function () {\r\n        return !this.unsigned && this.high < 0;\r\n    };\r\n    Long.prototype.isPositive = function () {\r\n        return this.unsigned || this.high >= 0;\r\n    };\r\n    Long.prototype.isOdd = function () {\r\n        return (this.low & 1) === 1;\r\n    };\r\n    Long.prototype.isEven = function () {\r\n        return (this.low & 1) === 0;\r\n    };\r\n    Long.prototype.equals = function (other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n            return false;\r\n        return this.high === other.high && this.low === other.low;\r\n    };\r\n    Long.prototype.notEquals = function (other) {\r\n        return !this.eq(other);\r\n    };\r\n    Long.prototype.lessThan = function (other) {\r\n        return this.comp(other) < 0;\r\n    };\r\n    Long.prototype.lessThanOrEqual = function (other) {\r\n        return this.comp(other) <= 0;\r\n    };\r\n    Long.prototype.greaterThan = function (other) {\r\n        return this.comp(other) > 0;\r\n    };\r\n    Long.prototype.greaterThanOrEqual = function (other) {\r\n        return this.comp(other) >= 0;\r\n    };\r\n    Long.prototype.compare = function (other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        if (this.eq(other))\r\n            return 0;\r\n        var thisNeg = this.isNegative(), otherNeg = other.isNegative();\r\n        if (thisNeg && !otherNeg)\r\n            return -1;\r\n        if (!thisNeg && otherNeg)\r\n            return 1;\r\n        if (!this.unsigned)\r\n            return this.sub(other).isNegative() ? -1 : 1;\r\n        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n    };\r\n    Long.prototype.negate = function () {\r\n        if (!this.unsigned && this.eq(MIN_VALUE))\r\n            return MIN_VALUE;\r\n        return this.not().add(ONE);\r\n    };\r\n    Long.prototype.absolute = function () {\r\n        if (!this.unsigned && this.isNegative())\r\n            return this.negate();\r\n        else\r\n            return this;\r\n    };\r\n    Long.prototype.add = function (addend) {\r\n        if (!isLong(addend))\r\n            addend = fromValue(addend);\r\n        var a48 = this.high >>> 16;\r\n        var a32 = this.high & 0xFFFF;\r\n        var a16 = this.low >>> 16;\r\n        var a00 = this.low & 0xFFFF;\r\n        var b48 = addend.high >>> 16;\r\n        var b32 = addend.high & 0xFFFF;\r\n        var b16 = addend.low >>> 16;\r\n        var b00 = addend.low & 0xFFFF;\r\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n        c00 += a00 + b00;\r\n        c16 += c00 >>> 16;\r\n        c00 &= 0xFFFF;\r\n        c16 += a16 + b16;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c32 += a32 + b32;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c48 += a48 + b48;\r\n        c48 &= 0xFFFF;\r\n        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n    };\r\n    Long.prototype.subtract = function (subtrahend) {\r\n        if (!isLong(subtrahend))\r\n            subtrahend = fromValue(subtrahend);\r\n        return this.add(subtrahend.neg());\r\n    };\r\n    Long.prototype.multiply = function (multiplier) {\r\n        if (this.isZero())\r\n            return ZERO;\r\n        if (!isLong(multiplier))\r\n            multiplier = fromValue(multiplier);\r\n        if (multiplier.isZero())\r\n            return ZERO;\r\n        if (this.eq(MIN_VALUE))\r\n            return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n        if (multiplier.eq(MIN_VALUE))\r\n            return this.isOdd() ? MIN_VALUE : ZERO;\r\n        if (this.isNegative()) {\r\n            if (multiplier.isNegative())\r\n                return this.neg().mul(multiplier.neg());\r\n            else\r\n                return this.neg().mul(multiplier).neg();\r\n        }\r\n        else if (multiplier.isNegative())\r\n            return this.mul(multiplier.neg()).neg();\r\n        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n        var a48 = this.high >>> 16;\r\n        var a32 = this.high & 0xFFFF;\r\n        var a16 = this.low >>> 16;\r\n        var a00 = this.low & 0xFFFF;\r\n        var b48 = multiplier.high >>> 16;\r\n        var b32 = multiplier.high & 0xFFFF;\r\n        var b16 = multiplier.low >>> 16;\r\n        var b00 = multiplier.low & 0xFFFF;\r\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n        c00 += a00 * b00;\r\n        c16 += c00 >>> 16;\r\n        c00 &= 0xFFFF;\r\n        c16 += a16 * b00;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c16 += a00 * b16;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c32 += a32 * b00;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c32 += a16 * b16;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c32 += a00 * b32;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n        c48 &= 0xFFFF;\r\n        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n    };\r\n    Long.prototype.divide = function (divisor) {\r\n        if (!isLong(divisor))\r\n            divisor = fromValue(divisor);\r\n        if (divisor.isZero())\r\n            throw Error('division by zero');\r\n        if (this.isZero())\r\n            return this.unsigned ? UZERO : ZERO;\r\n        var approx = 0, rem = ZERO, res = ZERO;\r\n        if (!this.unsigned) {\r\n            if (this.eq(MIN_VALUE)) {\r\n                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                    return MIN_VALUE;\r\n                else if (divisor.eq(MIN_VALUE))\r\n                    return ONE;\r\n                else {\r\n                    var halfThis = this.shr(1);\r\n                    var approx_1 = halfThis.div(divisor).shl(1);\r\n                    if (approx_1.eq(ZERO)) {\r\n                        return divisor.isNegative() ? ONE : NEG_ONE;\r\n                    }\r\n                    else {\r\n                        rem = this.sub(divisor.mul(approx_1));\r\n                        res = approx_1.add(rem.div(divisor));\r\n                        return res;\r\n                    }\r\n                }\r\n            }\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return this.unsigned ? UZERO : ZERO;\r\n            if (this.isNegative()) {\r\n                if (divisor.isNegative())\r\n                    return this.neg().div(divisor.neg());\r\n                return this.neg().div(divisor).neg();\r\n            }\r\n            else if (divisor.isNegative())\r\n                return this.div(divisor.neg()).neg();\r\n            res = ZERO;\r\n        }\r\n        else {\r\n            if (!divisor.unsigned)\r\n                divisor = divisor.toUnsigned();\r\n            if (divisor.gt(this))\r\n                return UZERO;\r\n            if (divisor.gt(this.shru(1)))\r\n                return UONE;\r\n            res = UZERO;\r\n        }\r\n        rem = this;\r\n        while (rem.gte(divisor)) {\r\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n            var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);\r\n            while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n                approx -= delta;\r\n                approxRes = fromNumber(approx, this.unsigned);\r\n                approxRem = approxRes.mul(divisor);\r\n            }\r\n            if (approxRes.isZero())\r\n                approxRes = ONE;\r\n            res = res.add(approxRes);\r\n            rem = rem.sub(approxRem);\r\n        }\r\n        return res;\r\n    };\r\n    Long.prototype.modulo = function (divisor) {\r\n        if (!isLong(divisor))\r\n            divisor = fromValue(divisor);\r\n        return this.sub(this.div(divisor).mul(divisor));\r\n    };\r\n    ;\r\n    Long.prototype.not = function () {\r\n        return fromBits(~this.low, ~this.high, this.unsigned);\r\n    };\r\n    ;\r\n    Long.prototype.and = function (other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n    };\r\n    Long.prototype.or = function (other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n    };\r\n    Long.prototype.xor = function (other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n    };\r\n    Long.prototype.shiftLeft = function (numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        numBits = numBits & 63;\r\n        if (numBits === 0)\r\n            return this;\r\n        else if (numBits < 32)\r\n            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n        else\r\n            return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n    };\r\n    Long.prototype.shiftRight = function (numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        numBits = numBits & 63;\r\n        if (numBits === 0)\r\n            return this;\r\n        else if (numBits < 32)\r\n            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n        else\r\n            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n    };\r\n    Long.prototype.shiftRightUnsigned = function (numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        numBits = numBits & 63;\r\n        if (numBits === 0)\r\n            return this;\r\n        else {\r\n            var high = this.high;\r\n            if (numBits < 32) {\r\n                var low = this.low;\r\n                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n            }\r\n            else if (numBits === 32)\r\n                return fromBits(high, 0, this.unsigned);\r\n            else\r\n                return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n        }\r\n    };\r\n    Long.prototype.toSigned = function () {\r\n        if (!this.unsigned)\r\n            return this;\r\n        return fromBits(this.low, this.high, false);\r\n    };\r\n    Long.prototype.toUnsigned = function () {\r\n        if (this.unsigned)\r\n            return this;\r\n        return fromBits(this.low, this.high, true);\r\n    };\r\n    Long.prototype.toBytes = function (le) {\r\n        return le ? this.toBytesLE() : this.toBytesBE();\r\n    };\r\n    Long.prototype.toBytesLE = function () {\r\n        var hi = this.high, lo = this.low;\r\n        return [\r\n            lo & 0xff,\r\n            (lo >>> 8) & 0xff,\r\n            (lo >>> 16) & 0xff,\r\n            (lo >>> 24) & 0xff,\r\n            hi & 0xff,\r\n            (hi >>> 8) & 0xff,\r\n            (hi >>> 16) & 0xff,\r\n            (hi >>> 24) & 0xff\r\n        ];\r\n    };\r\n    Long.prototype.toBytesBE = function () {\r\n        var hi = this.high, lo = this.low;\r\n        return [\r\n            (hi >>> 24) & 0xff,\r\n            (hi >>> 16) & 0xff,\r\n            (hi >>> 8) & 0xff,\r\n            hi & 0xff,\r\n            (lo >>> 24) & 0xff,\r\n            (lo >>> 16) & 0xff,\r\n            (lo >>> 8) & 0xff,\r\n            lo & 0xff\r\n        ];\r\n    };\r\n    Long.prototype[_Symbol.reflection] = function () {\r\n        return {\r\n            type: \"System.Int64\",\r\n            interfaces: [\"FSharpRecord\", \"System.IComparable\"],\r\n            properties: {\r\n                low: \"number\",\r\n                high: \"number\",\r\n                unsigned: \"boolean\"\r\n            }\r\n        };\r\n    };\r\n    return Long;\r\n}());\r\nexport { Long };\r\nvar INT_CACHE = {};\r\nvar UINT_CACHE = {};\r\nexport function isLong(obj) {\r\n    return (obj && obj instanceof Long);\r\n}\r\nexport function fromInt(value, unsigned) {\r\n    if (unsigned === void 0) { unsigned = false; }\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n    else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\nexport function fromNumber(value, unsigned) {\r\n    if (unsigned === void 0) { unsigned = false; }\r\n    if (isNaN(value) || !isFinite(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    }\r\n    else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\nexport function fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\nvar pow_dbl = Math.pow;\r\nexport function fromString(str, unsigned, radix) {\r\n    if (unsigned === void 0) { unsigned = false; }\r\n    if (radix === void 0) { radix = 10; }\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        radix = unsigned,\r\n            unsigned = false;\r\n    }\r\n    else {\r\n        unsigned = !!unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    var p = str.indexOf('-');\r\n    if (p > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        }\r\n        else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\nexport function fromValue(val) {\r\n    if (val instanceof Long)\r\n        return val;\r\n    if (typeof val === 'number')\r\n        return fromNumber(val);\r\n    if (typeof val === 'string')\r\n        return fromString(val);\r\n    return fromBits(val.low, val.high, val.unsigned);\r\n}\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\nexport var ZERO = fromInt(0);\r\nexport var UZERO = fromInt(0, true);\r\nexport var ONE = fromInt(1);\r\nexport var UONE = fromInt(1, true);\r\nexport var NEG_ONE = fromInt(-1);\r\nexport var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\r\nexport var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\r\nexport var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/Long.js\n// module id = 8\n// module chunks = 0","export function create(pattern, options) {\r\n    var flags = \"g\";\r\n    flags += options & 1 ? \"i\" : \"\";\r\n    flags += options & 2 ? \"m\" : \"\";\r\n    return new RegExp(pattern, flags);\r\n}\r\nexport function escape(str) {\r\n    return str.replace(/[\\-\\[\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n}\r\nexport function unescape(str) {\r\n    return str.replace(/\\\\([\\-\\[\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|])/g, \"$1\");\r\n}\r\nexport function isMatch(str, pattern, options) {\r\n    if (options === void 0) { options = 0; }\r\n    var reg = str instanceof RegExp\r\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\r\n        : reg = create(pattern, options);\r\n    return reg.test(str);\r\n}\r\nexport function match(str, pattern, options) {\r\n    if (options === void 0) { options = 0; }\r\n    var reg = str instanceof RegExp\r\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\r\n        : reg = create(pattern, options);\r\n    return reg.exec(str);\r\n}\r\nexport function matches(str, pattern, options) {\r\n    if (options === void 0) { options = 0; }\r\n    var reg = str instanceof RegExp\r\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\r\n        : reg = create(pattern, options);\r\n    if (!reg.global)\r\n        throw new Error(\"Non-global RegExp\");\r\n    var m;\r\n    var matches = [];\r\n    while ((m = reg.exec(str)) !== null)\r\n        matches.push(m);\r\n    return matches;\r\n}\r\nexport function options(reg) {\r\n    var options = 256;\r\n    options |= reg.ignoreCase ? 1 : 0;\r\n    options |= reg.multiline ? 2 : 0;\r\n    return options;\r\n}\r\nexport function replace(reg, input, replacement, limit, offset) {\r\n    if (offset === void 0) { offset = 0; }\r\n    function replacer() {\r\n        var res = arguments[0];\r\n        if (limit !== 0) {\r\n            limit--;\r\n            var match_1 = [];\r\n            var len = arguments.length;\r\n            for (var i = 0; i < len - 2; i++)\r\n                match_1.push(arguments[i]);\r\n            match_1.index = arguments[len - 2];\r\n            match_1.input = arguments[len - 1];\r\n            res = replacement(match_1);\r\n        }\r\n        return res;\r\n    }\r\n    if (typeof reg == \"string\") {\r\n        var tmp = reg;\r\n        reg = create(input, limit);\r\n        input = tmp;\r\n        limit = undefined;\r\n    }\r\n    if (typeof replacement == \"function\") {\r\n        limit = limit == null ? -1 : limit;\r\n        return input.substring(0, offset) + input.substring(offset).replace(reg, replacer);\r\n    }\r\n    else {\r\n        if (limit != null) {\r\n            var m = void 0;\r\n            var sub1 = input.substring(offset);\r\n            var _matches = matches(reg, sub1);\r\n            var sub2 = matches.length > limit ? (m = _matches[limit - 1], sub1.substring(0, m.index + m[0].length)) : sub1;\r\n            return input.substring(0, offset) + sub2.replace(reg, replacement) + input.substring(offset + sub2.length);\r\n        }\r\n        else {\r\n            return input.replace(reg, replacement);\r\n        }\r\n    }\r\n}\r\nexport function split(reg, input, limit, offset) {\r\n    if (offset === void 0) { offset = 0; }\r\n    if (typeof reg == \"string\") {\r\n        var tmp = reg;\r\n        reg = create(input, limit);\r\n        input = tmp;\r\n        limit = undefined;\r\n    }\r\n    input = input.substring(offset);\r\n    return input.split(reg, limit);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/RegExp.js\n// module id = 9\n// module chunks = 0","import List from \"./List\";\r\nimport { ofArray as listOfArray } from \"./List\";\r\nimport { toString } from \"./Util\";\r\nimport GenericComparer from \"./GenericComparer\";\r\nimport FSymbol from \"./Symbol\";\r\nimport { iterate as seqIterate } from \"./Seq\";\r\nimport { fold as seqFold } from \"./Seq\";\r\nimport { reduce as seqReduce } from \"./Seq\";\r\nimport { forAll as seqForAll } from \"./Seq\";\r\nimport { exists as seqExists } from \"./Seq\";\r\nimport { choose as seqChoose } from \"./Seq\";\r\nimport { scan as seqScan } from \"./Seq\";\r\nexport function distinctBy(f, xs) {\r\n    return seqChoose(function (tup) { return tup[0]; }, seqScan(function (tup, x) {\r\n        var acc = tup[1];\r\n        var k = f(x);\r\n        return acc.has(k) ? [null, acc] : [x, add(k, acc)];\r\n    }, [null, create()], xs));\r\n}\r\nexport function distinct(xs) {\r\n    return distinctBy(function (x) { return x; }, xs);\r\n}\r\nvar SetTree = (function () {\r\n    function SetTree(caseName, fields) {\r\n        this.Case = caseName;\r\n        this.Fields = fields;\r\n    }\r\n    return SetTree;\r\n}());\r\nexport { SetTree };\r\nvar tree_tolerance = 2;\r\nfunction tree_countAux(s, acc) {\r\n    return s.Case === \"SetOne\" ? acc + 1 : s.Case === \"SetEmpty\" ? acc : tree_countAux(s.Fields[1], tree_countAux(s.Fields[2], acc + 1));\r\n}\r\nfunction tree_count(s) {\r\n    return tree_countAux(s, 0);\r\n}\r\nfunction tree_SetOne(n) {\r\n    return new SetTree(\"SetOne\", [n]);\r\n}\r\nfunction tree_SetNode(x, l, r, h) {\r\n    return new SetTree(\"SetNode\", [x, l, r, h]);\r\n}\r\nfunction tree_height(t) {\r\n    return t.Case === \"SetOne\" ? 1 : t.Case === \"SetNode\" ? t.Fields[3] : 0;\r\n}\r\nfunction tree_mk(l, k, r) {\r\n    var matchValue = [l, r];\r\n    var $target1 = function () {\r\n        var hl = tree_height(l);\r\n        var hr = tree_height(r);\r\n        var m = hl < hr ? hr : hl;\r\n        return tree_SetNode(k, l, r, m + 1);\r\n    };\r\n    if (matchValue[0].Case === \"SetEmpty\") {\r\n        if (matchValue[1].Case === \"SetEmpty\") {\r\n            return tree_SetOne(k);\r\n        }\r\n        else {\r\n            return $target1();\r\n        }\r\n    }\r\n    else {\r\n        return $target1();\r\n    }\r\n}\r\nfunction tree_rebalance(t1, k, t2) {\r\n    var t1h = tree_height(t1);\r\n    var t2h = tree_height(t2);\r\n    if (t2h > t1h + tree_tolerance) {\r\n        if (t2.Case === \"SetNode\") {\r\n            if (tree_height(t2.Fields[1]) > t1h + 1) {\r\n                if (t2.Fields[1].Case === \"SetNode\") {\r\n                    return tree_mk(tree_mk(t1, k, t2.Fields[1].Fields[1]), t2.Fields[1].Fields[0], tree_mk(t2.Fields[1].Fields[2], t2.Fields[0], t2.Fields[2]));\r\n                }\r\n                else {\r\n                    throw new Error(\"rebalance\");\r\n                }\r\n            }\r\n            else {\r\n                return tree_mk(tree_mk(t1, k, t2.Fields[1]), t2.Fields[0], t2.Fields[2]);\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(\"rebalance\");\r\n        }\r\n    }\r\n    else {\r\n        if (t1h > t2h + tree_tolerance) {\r\n            if (t1.Case === \"SetNode\") {\r\n                if (tree_height(t1.Fields[2]) > t2h + 1) {\r\n                    if (t1.Fields[2].Case === \"SetNode\") {\r\n                        return tree_mk(tree_mk(t1.Fields[1], t1.Fields[0], t1.Fields[2].Fields[1]), t1.Fields[2].Fields[0], tree_mk(t1.Fields[2].Fields[2], k, t2));\r\n                    }\r\n                    else {\r\n                        throw new Error(\"rebalance\");\r\n                    }\r\n                }\r\n                else {\r\n                    return tree_mk(t1.Fields[1], t1.Fields[0], tree_mk(t1.Fields[2], k, t2));\r\n                }\r\n            }\r\n            else {\r\n                throw new Error(\"rebalance\");\r\n            }\r\n        }\r\n        else {\r\n            return tree_mk(t1, k, t2);\r\n        }\r\n    }\r\n}\r\nfunction tree_add(comparer, k, t) {\r\n    if (t.Case === \"SetOne\") {\r\n        var c = comparer.Compare(k, t.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_SetNode(k, new SetTree(\"SetEmpty\", []), t, 2);\r\n        }\r\n        else if (c === 0) {\r\n            return t;\r\n        }\r\n        else {\r\n            return tree_SetNode(k, t, new SetTree(\"SetEmpty\", []), 2);\r\n        }\r\n    }\r\n    else if (t.Case === \"SetEmpty\") {\r\n        return tree_SetOne(k);\r\n    }\r\n    else {\r\n        var c = comparer.Compare(k, t.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_rebalance(tree_add(comparer, k, t.Fields[1]), t.Fields[0], t.Fields[2]);\r\n        }\r\n        else if (c === 0) {\r\n            return t;\r\n        }\r\n        else {\r\n            return tree_rebalance(t.Fields[1], t.Fields[0], tree_add(comparer, k, t.Fields[2]));\r\n        }\r\n    }\r\n}\r\nfunction tree_balance(comparer, t1, k, t2) {\r\n    var matchValue = [t1, t2];\r\n    var $target1 = function (t1_1) { return tree_add(comparer, k, t1_1); };\r\n    var $target2 = function (k1, t2_1) { return tree_add(comparer, k, tree_add(comparer, k1, t2_1)); };\r\n    if (matchValue[0].Case === \"SetOne\") {\r\n        if (matchValue[1].Case === \"SetEmpty\") {\r\n            return $target1(matchValue[0]);\r\n        }\r\n        else {\r\n            if (matchValue[1].Case === \"SetOne\") {\r\n                return $target2(matchValue[0].Fields[0], matchValue[1]);\r\n            }\r\n            else {\r\n                return $target2(matchValue[0].Fields[0], matchValue[1]);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (matchValue[0].Case === \"SetNode\") {\r\n            if (matchValue[1].Case === \"SetOne\") {\r\n                var k2 = matchValue[1].Fields[0];\r\n                var t1_1 = matchValue[0];\r\n                return tree_add(comparer, k, tree_add(comparer, k2, t1_1));\r\n            }\r\n            else {\r\n                if (matchValue[1].Case === \"SetNode\") {\r\n                    var h1 = matchValue[0].Fields[3];\r\n                    var h2 = matchValue[1].Fields[3];\r\n                    var k1 = matchValue[0].Fields[0];\r\n                    var k2 = matchValue[1].Fields[0];\r\n                    var t11 = matchValue[0].Fields[1];\r\n                    var t12 = matchValue[0].Fields[2];\r\n                    var t21 = matchValue[1].Fields[1];\r\n                    var t22 = matchValue[1].Fields[2];\r\n                    if (h1 + tree_tolerance < h2) {\r\n                        return tree_rebalance(tree_balance(comparer, t1, k, t21), k2, t22);\r\n                    }\r\n                    else {\r\n                        if (h2 + tree_tolerance < h1) {\r\n                            return tree_rebalance(t11, k1, tree_balance(comparer, t12, k, t2));\r\n                        }\r\n                        else {\r\n                            return tree_mk(t1, k, t2);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    return $target1(matchValue[0]);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var t2_1 = matchValue[1];\r\n            return tree_add(comparer, k, t2_1);\r\n        }\r\n    }\r\n}\r\nfunction tree_split(comparer, pivot, t) {\r\n    if (t.Case === \"SetOne\") {\r\n        var c = comparer.Compare(t.Fields[0], pivot);\r\n        if (c < 0) {\r\n            return [t, false, new SetTree(\"SetEmpty\", [])];\r\n        }\r\n        else if (c === 0) {\r\n            return [new SetTree(\"SetEmpty\", []), true, new SetTree(\"SetEmpty\", [])];\r\n        }\r\n        else {\r\n            return [new SetTree(\"SetEmpty\", []), false, t];\r\n        }\r\n    }\r\n    else if (t.Case === \"SetEmpty\") {\r\n        return [new SetTree(\"SetEmpty\", []), false, new SetTree(\"SetEmpty\", [])];\r\n    }\r\n    else {\r\n        var c = comparer.Compare(pivot, t.Fields[0]);\r\n        if (c < 0) {\r\n            var patternInput = tree_split(comparer, pivot, t.Fields[1]);\r\n            return [patternInput[0], patternInput[1], tree_balance(comparer, patternInput[2], t.Fields[0], t.Fields[2])];\r\n        }\r\n        else if (c === 0) {\r\n            return [t.Fields[1], true, t.Fields[2]];\r\n        }\r\n        else {\r\n            var patternInput = tree_split(comparer, pivot, t.Fields[2]);\r\n            return [tree_balance(comparer, t.Fields[1], t.Fields[0], patternInput[0]), patternInput[1], patternInput[2]];\r\n        }\r\n    }\r\n}\r\nfunction tree_spliceOutSuccessor(t) {\r\n    if (t.Case === \"SetOne\") {\r\n        return [t.Fields[0], new SetTree(\"SetEmpty\", [])];\r\n    }\r\n    else if (t.Case === \"SetNode\") {\r\n        if (t.Fields[1].Case === \"SetEmpty\") {\r\n            return [t.Fields[0], t.Fields[2]];\r\n        }\r\n        else {\r\n            var patternInput = tree_spliceOutSuccessor(t.Fields[1]);\r\n            return [patternInput[0], tree_mk(patternInput[1], t.Fields[0], t.Fields[2])];\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"internal error: Map.spliceOutSuccessor\");\r\n    }\r\n}\r\nfunction tree_remove(comparer, k, t) {\r\n    if (t.Case === \"SetOne\") {\r\n        var c = comparer.Compare(k, t.Fields[0]);\r\n        if (c === 0) {\r\n            return new SetTree(\"SetEmpty\", []);\r\n        }\r\n        else {\r\n            return t;\r\n        }\r\n    }\r\n    else if (t.Case === \"SetNode\") {\r\n        var c = comparer.Compare(k, t.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_rebalance(tree_remove(comparer, k, t.Fields[1]), t.Fields[0], t.Fields[2]);\r\n        }\r\n        else if (c === 0) {\r\n            var matchValue = [t.Fields[1], t.Fields[2]];\r\n            if (matchValue[0].Case === \"SetEmpty\") {\r\n                return t.Fields[2];\r\n            }\r\n            else if (matchValue[1].Case === \"SetEmpty\") {\r\n                return t.Fields[1];\r\n            }\r\n            else {\r\n                var patternInput = tree_spliceOutSuccessor(t.Fields[2]);\r\n                return tree_mk(t.Fields[1], patternInput[0], patternInput[1]);\r\n            }\r\n        }\r\n        else {\r\n            return tree_rebalance(t.Fields[1], t.Fields[0], tree_remove(comparer, k, t.Fields[2]));\r\n        }\r\n    }\r\n    else {\r\n        return t;\r\n    }\r\n}\r\nfunction tree_mem(comparer, k, t) {\r\n    if (t.Case === \"SetOne\") {\r\n        return comparer.Compare(k, t.Fields[0]) === 0;\r\n    }\r\n    else if (t.Case === \"SetEmpty\") {\r\n        return false;\r\n    }\r\n    else {\r\n        var c = comparer.Compare(k, t.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_mem(comparer, k, t.Fields[1]);\r\n        }\r\n        else if (c === 0) {\r\n            return true;\r\n        }\r\n        else {\r\n            return tree_mem(comparer, k, t.Fields[2]);\r\n        }\r\n    }\r\n}\r\nfunction tree_iter(f, t) {\r\n    if (t.Case === \"SetOne\") {\r\n        f(t.Fields[0]);\r\n    }\r\n    else {\r\n        if (t.Case === \"SetEmpty\") { }\r\n        else {\r\n            tree_iter(f, t.Fields[1]);\r\n            f(t.Fields[0]);\r\n            tree_iter(f, t.Fields[2]);\r\n        }\r\n    }\r\n}\r\nfunction tree_foldBack(f, m, x) {\r\n    return m.Case === \"SetOne\" ? f(m.Fields[0], x) : m.Case === \"SetEmpty\" ? x : tree_foldBack(f, m.Fields[1], f(m.Fields[0], tree_foldBack(f, m.Fields[2], x)));\r\n}\r\nfunction tree_fold(f, x, m) {\r\n    if (m.Case === \"SetOne\") {\r\n        return f(x, m.Fields[0]);\r\n    }\r\n    else if (m.Case === \"SetEmpty\") {\r\n        return x;\r\n    }\r\n    else {\r\n        var x_1 = tree_fold(f, x, m.Fields[1]);\r\n        var x_2 = f(x_1, m.Fields[0]);\r\n        return tree_fold(f, x_2, m.Fields[2]);\r\n    }\r\n}\r\nfunction tree_forall(f, m) {\r\n    return m.Case === \"SetOne\" ? f(m.Fields[0]) : m.Case === \"SetEmpty\" ? true : (f(m.Fields[0]) ? tree_forall(f, m.Fields[1]) : false) ? tree_forall(f, m.Fields[2]) : false;\r\n}\r\nfunction tree_exists(f, m) {\r\n    return m.Case === \"SetOne\" ? f(m.Fields[0]) : m.Case === \"SetEmpty\" ? false : (f(m.Fields[0]) ? true : tree_exists(f, m.Fields[1])) ? true : tree_exists(f, m.Fields[2]);\r\n}\r\nfunction tree_isEmpty(m) {\r\n    return m.Case === \"SetEmpty\" ? true : false;\r\n}\r\nfunction tree_subset(comparer, a, b) {\r\n    return tree_forall(function (x) { return tree_mem(comparer, x, b); }, a);\r\n}\r\nfunction tree_psubset(comparer, a, b) {\r\n    return tree_forall(function (x) { return tree_mem(comparer, x, b); }, a) ? tree_exists(function (x) { return !tree_mem(comparer, x, a); }, b) : false;\r\n}\r\nfunction tree_filterAux(comparer, f, s, acc) {\r\n    if (s.Case === \"SetOne\") {\r\n        if (f(s.Fields[0])) {\r\n            return tree_add(comparer, s.Fields[0], acc);\r\n        }\r\n        else {\r\n            return acc;\r\n        }\r\n    }\r\n    else if (s.Case === \"SetEmpty\") {\r\n        return acc;\r\n    }\r\n    else {\r\n        var acc_1 = f(s.Fields[0]) ? tree_add(comparer, s.Fields[0], acc) : acc;\r\n        return tree_filterAux(comparer, f, s.Fields[1], tree_filterAux(comparer, f, s.Fields[2], acc_1));\r\n    }\r\n}\r\nfunction tree_filter(comparer, f, s) {\r\n    return tree_filterAux(comparer, f, s, new SetTree(\"SetEmpty\", []));\r\n}\r\nfunction tree_diffAux(comparer, m, acc) {\r\n    return m.Case === \"SetOne\" ? tree_remove(comparer, m.Fields[0], acc) : m.Case === \"SetEmpty\" ? acc : tree_diffAux(comparer, m.Fields[1], tree_diffAux(comparer, m.Fields[2], tree_remove(comparer, m.Fields[0], acc)));\r\n}\r\nfunction tree_diff(comparer, a, b) {\r\n    return tree_diffAux(comparer, b, a);\r\n}\r\nfunction tree_union(comparer, t1, t2) {\r\n    var matchValue = [t1, t2];\r\n    var $target2 = function (t) { return t; };\r\n    var $target3 = function (k1, t2_1) { return tree_add(comparer, k1, t2_1); };\r\n    if (matchValue[0].Case === \"SetEmpty\") {\r\n        var t = matchValue[1];\r\n        return t;\r\n    }\r\n    else {\r\n        if (matchValue[0].Case === \"SetOne\") {\r\n            if (matchValue[1].Case === \"SetEmpty\") {\r\n                return $target2(matchValue[0]);\r\n            }\r\n            else {\r\n                if (matchValue[1].Case === \"SetOne\") {\r\n                    return $target3(matchValue[0].Fields[0], matchValue[1]);\r\n                }\r\n                else {\r\n                    return $target3(matchValue[0].Fields[0], matchValue[1]);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (matchValue[1].Case === \"SetEmpty\") {\r\n                return $target2(matchValue[0]);\r\n            }\r\n            else {\r\n                if (matchValue[1].Case === \"SetOne\") {\r\n                    var k2 = matchValue[1].Fields[0];\r\n                    var t1_1 = matchValue[0];\r\n                    return tree_add(comparer, k2, t1_1);\r\n                }\r\n                else {\r\n                    var h1 = matchValue[0].Fields[3];\r\n                    var h2 = matchValue[1].Fields[3];\r\n                    var k1 = matchValue[0].Fields[0];\r\n                    var k2 = matchValue[1].Fields[0];\r\n                    var t11 = matchValue[0].Fields[1];\r\n                    var t12 = matchValue[0].Fields[2];\r\n                    var t21 = matchValue[1].Fields[1];\r\n                    var t22 = matchValue[1].Fields[2];\r\n                    if (h1 > h2) {\r\n                        var patternInput = tree_split(comparer, k1, t2);\r\n                        var lo = patternInput[0];\r\n                        var hi = patternInput[2];\r\n                        return tree_balance(comparer, tree_union(comparer, t11, lo), k1, tree_union(comparer, t12, hi));\r\n                    }\r\n                    else {\r\n                        var patternInput = tree_split(comparer, k2, t1);\r\n                        var lo = patternInput[0];\r\n                        var hi = patternInput[2];\r\n                        return tree_balance(comparer, tree_union(comparer, t21, lo), k2, tree_union(comparer, t22, hi));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction tree_intersectionAux(comparer, b, m, acc) {\r\n    if (m.Case === \"SetOne\") {\r\n        if (tree_mem(comparer, m.Fields[0], b)) {\r\n            return tree_add(comparer, m.Fields[0], acc);\r\n        }\r\n        else {\r\n            return acc;\r\n        }\r\n    }\r\n    else if (m.Case === \"SetEmpty\") {\r\n        return acc;\r\n    }\r\n    else {\r\n        var acc_1 = tree_intersectionAux(comparer, b, m.Fields[2], acc);\r\n        var acc_2 = tree_mem(comparer, m.Fields[0], b) ? tree_add(comparer, m.Fields[0], acc_1) : acc_1;\r\n        return tree_intersectionAux(comparer, b, m.Fields[1], acc_2);\r\n    }\r\n}\r\nfunction tree_intersection(comparer, a, b) {\r\n    return tree_intersectionAux(comparer, b, a, new SetTree(\"SetEmpty\", []));\r\n}\r\nfunction tree_partition1(comparer, f, k, acc1, acc2) {\r\n    return f(k) ? [tree_add(comparer, k, acc1), acc2] : [acc1, tree_add(comparer, k, acc2)];\r\n}\r\nfunction tree_partitionAux(comparer, f, s, acc_0, acc_1) {\r\n    var acc = [acc_0, acc_1];\r\n    if (s.Case === \"SetOne\") {\r\n        var acc1 = acc[0];\r\n        var acc2 = acc[1];\r\n        return tree_partition1(comparer, f, s.Fields[0], acc1, acc2);\r\n    }\r\n    else {\r\n        if (s.Case === \"SetEmpty\") {\r\n            return acc;\r\n        }\r\n        else {\r\n            var acc_2 = tree_partitionAux(comparer, f, s.Fields[2], acc[0], acc[1]);\r\n            var acc_3 = tree_partition1(comparer, f, s.Fields[0], acc_2[0], acc_2[1]);\r\n            return tree_partitionAux(comparer, f, s.Fields[1], acc_3[0], acc_3[1]);\r\n        }\r\n    }\r\n}\r\nfunction tree_partition(comparer, f, s) {\r\n    var seed = [new SetTree(\"SetEmpty\", []), new SetTree(\"SetEmpty\", [])];\r\n    var arg30_ = seed[0];\r\n    var arg31_ = seed[1];\r\n    return tree_partitionAux(comparer, f, s, arg30_, arg31_);\r\n}\r\nfunction tree_minimumElementAux(s, n) {\r\n    return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? n : tree_minimumElementAux(s.Fields[1], s.Fields[0]);\r\n}\r\nfunction tree_minimumElementOpt(s) {\r\n    return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? null : tree_minimumElementAux(s.Fields[1], s.Fields[0]);\r\n}\r\nfunction tree_maximumElementAux(s, n) {\r\n    return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? n : tree_maximumElementAux(s.Fields[2], s.Fields[0]);\r\n}\r\nfunction tree_maximumElementOpt(s) {\r\n    return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? null : tree_maximumElementAux(s.Fields[2], s.Fields[0]);\r\n}\r\nfunction tree_minimumElement(s) {\r\n    var matchValue = tree_minimumElementOpt(s);\r\n    if (matchValue == null) {\r\n        throw new Error(\"Set contains no elements\");\r\n    }\r\n    else {\r\n        return matchValue;\r\n    }\r\n}\r\nfunction tree_maximumElement(s) {\r\n    var matchValue = tree_maximumElementOpt(s);\r\n    if (matchValue == null) {\r\n        throw new Error(\"Set contains no elements\");\r\n    }\r\n    else {\r\n        return matchValue;\r\n    }\r\n}\r\nfunction tree_collapseLHS(stack) {\r\n    return stack.tail != null\r\n        ? stack.head.Case === \"SetOne\"\r\n            ? stack\r\n            : stack.head.Case === \"SetNode\"\r\n                ? tree_collapseLHS(listOfArray([\r\n                    stack.head.Fields[1],\r\n                    tree_SetOne(stack.head.Fields[0]),\r\n                    stack.head.Fields[2]\r\n                ], stack.tail))\r\n                : tree_collapseLHS(stack.tail)\r\n        : new List();\r\n}\r\nfunction tree_mkIterator(s) {\r\n    return { stack: tree_collapseLHS(new List(s, new List())), started: false };\r\n}\r\n;\r\nfunction tree_moveNext(i) {\r\n    function current(i) {\r\n        if (i.stack.tail == null) {\r\n            return null;\r\n        }\r\n        else if (i.stack.head.Case === \"SetOne\") {\r\n            return i.stack.head.Fields[0];\r\n        }\r\n        throw new Error(\"Please report error: Set iterator, unexpected stack for current\");\r\n    }\r\n    if (i.started) {\r\n        if (i.stack.tail == null) {\r\n            return { done: true, value: null };\r\n        }\r\n        else {\r\n            if (i.stack.head.Case === \"SetOne\") {\r\n                i.stack = tree_collapseLHS(i.stack.tail);\r\n                return {\r\n                    done: i.stack.tail == null,\r\n                    value: current(i)\r\n                };\r\n            }\r\n            else {\r\n                throw new Error(\"Please report error: Set iterator, unexpected stack for moveNext\");\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        i.started = true;\r\n        return {\r\n            done: i.stack.tail == null,\r\n            value: current(i)\r\n        };\r\n    }\r\n    ;\r\n}\r\nfunction tree_compareStacks(comparer, l1, l2) {\r\n    var $target8 = function (n1k, t1) { return tree_compareStacks(comparer, listOfArray([new SetTree(\"SetEmpty\", []), tree_SetOne(n1k)], t1), l2); };\r\n    var $target9 = function (n1k, n1l, n1r, t1) { return tree_compareStacks(comparer, listOfArray([n1l, tree_SetNode(n1k, new SetTree(\"SetEmpty\", []), n1r, 0)], t1), l2); };\r\n    var $target11 = function (n2k, n2l, n2r, t2) { return tree_compareStacks(comparer, l1, listOfArray([n2l, tree_SetNode(n2k, new SetTree(\"SetEmpty\", []), n2r, 0)], t2)); };\r\n    if (l1.tail != null) {\r\n        if (l2.tail != null) {\r\n            if (l2.head.Case === \"SetOne\") {\r\n                if (l1.head.Case === \"SetOne\") {\r\n                    var n1k = l1.head.Fields[0], n2k = l2.head.Fields[0], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);\r\n                    if (c !== 0) {\r\n                        return c;\r\n                    }\r\n                    else {\r\n                        return tree_compareStacks(comparer, t1, t2);\r\n                    }\r\n                }\r\n                else {\r\n                    if (l1.head.Case === \"SetNode\") {\r\n                        if (l1.head.Fields[1].Case === \"SetEmpty\") {\r\n                            var emp = l1.head.Fields[1], n1k = l1.head.Fields[0], n1r = l1.head.Fields[2], n2k = l2.head.Fields[0], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);\r\n                            if (c !== 0) {\r\n                                return c;\r\n                            }\r\n                            else {\r\n                                return tree_compareStacks(comparer, listOfArray([n1r], t1), listOfArray([emp], t2));\r\n                            }\r\n                        }\r\n                        else {\r\n                            return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\r\n                        }\r\n                    }\r\n                    else {\r\n                        var n2k = l2.head.Fields[0], t2 = l2.tail;\r\n                        return tree_compareStacks(comparer, l1, listOfArray([new SetTree(\"SetEmpty\", []), tree_SetOne(n2k)], t2));\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (l2.head.Case === \"SetNode\") {\r\n                    if (l2.head.Fields[1].Case === \"SetEmpty\") {\r\n                        if (l1.head.Case === \"SetOne\") {\r\n                            var n1k = l1.head.Fields[0], n2k = l2.head.Fields[0], n2r = l2.head.Fields[2], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);\r\n                            if (c !== 0) {\r\n                                return c;\r\n                            }\r\n                            else {\r\n                                return tree_compareStacks(comparer, listOfArray([new SetTree(\"SetEmpty\", [])], t1), listOfArray([n2r], t2));\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (l1.head.Case === \"SetNode\") {\r\n                                if (l1.head.Fields[1].Case === \"SetEmpty\") {\r\n                                    var n1k = l1.head.Fields[0], n1r = l1.head.Fields[2], n2k = l2.head.Fields[0], n2r = l2.head.Fields[2], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);\r\n                                    if (c !== 0) {\r\n                                        return c;\r\n                                    }\r\n                                    else {\r\n                                        return tree_compareStacks(comparer, listOfArray([n1r], t1), listOfArray([n2r], t2));\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\r\n                                }\r\n                            }\r\n                            else {\r\n                                return $target11(l2.head.Fields[0], l2.head.Fields[1], l2.head.Fields[2], l2.tail);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (l1.head.Case === \"SetOne\") {\r\n                            return $target8(l1.head.Fields[0], l1.tail);\r\n                        }\r\n                        else {\r\n                            if (l1.head.Case === \"SetNode\") {\r\n                                return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\r\n                            }\r\n                            else {\r\n                                return $target11(l2.head.Fields[0], l2.head.Fields[1], l2.head.Fields[2], l2.tail);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (l1.head.Case === \"SetOne\") {\r\n                        return $target8(l1.head.Fields[0], l1.tail);\r\n                    }\r\n                    else {\r\n                        if (l1.head.Case === \"SetNode\") {\r\n                            return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\r\n                        }\r\n                        else {\r\n                            return tree_compareStacks(comparer, l1.tail, l2.tail);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n    else {\r\n        if (l2.tail != null) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\nfunction tree_compare(comparer, s1, s2) {\r\n    if (s1.Case === \"SetEmpty\") {\r\n        if (s2.Case === \"SetEmpty\") {\r\n            return 0;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n    else {\r\n        if (s2.Case === \"SetEmpty\") {\r\n            return 1;\r\n        }\r\n        else {\r\n            return tree_compareStacks(comparer, listOfArray([s1]), listOfArray([s2]));\r\n        }\r\n    }\r\n}\r\nfunction tree_mkFromEnumerator(comparer, acc, e) {\r\n    var cur = e.next();\r\n    while (!cur.done) {\r\n        acc = tree_add(comparer, cur.value, acc);\r\n        cur = e.next();\r\n    }\r\n    return acc;\r\n}\r\nfunction tree_ofSeq(comparer, c) {\r\n    var ie = c[Symbol.iterator]();\r\n    return tree_mkFromEnumerator(comparer, new SetTree(\"SetEmpty\", []), ie);\r\n}\r\nvar FableSet = (function () {\r\n    function FableSet() {\r\n    }\r\n    FableSet.prototype.ToString = function () {\r\n        return \"set [\" + Array.from(this).map(toString).join(\"; \") + \"]\";\r\n    };\r\n    FableSet.prototype.Equals = function (s2) {\r\n        return this.CompareTo(s2) === 0;\r\n    };\r\n    FableSet.prototype.CompareTo = function (s2) {\r\n        return this === s2 ? 0 : tree_compare(this.comparer, this.tree, s2.tree);\r\n    };\r\n    FableSet.prototype[Symbol.iterator] = function () {\r\n        var i = tree_mkIterator(this.tree);\r\n        return {\r\n            next: function () { return tree_moveNext(i); }\r\n        };\r\n    };\r\n    FableSet.prototype.values = function () {\r\n        return this[Symbol.iterator]();\r\n    };\r\n    FableSet.prototype.has = function (v) {\r\n        return tree_mem(this.comparer, v, this.tree);\r\n    };\r\n    FableSet.prototype.add = function (v) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    FableSet.prototype.delete = function (v) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    FableSet.prototype.clear = function () {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    Object.defineProperty(FableSet.prototype, \"size\", {\r\n        get: function () {\r\n            return tree_count(this.tree);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FableSet.prototype[FSymbol.reflection] = function () {\r\n        return {\r\n            type: \"Microsoft.FSharp.Collections.FSharpSet\",\r\n            interfaces: [\"System.IEquatable\", \"System.IComparable\"]\r\n        };\r\n    };\r\n    return FableSet;\r\n}());\r\nexport default FableSet;\r\nfunction from(comparer, tree) {\r\n    var s = new FableSet();\r\n    s.tree = tree;\r\n    s.comparer = comparer || new GenericComparer();\r\n    return s;\r\n}\r\nexport function create(ie, comparer) {\r\n    comparer = comparer || new GenericComparer();\r\n    return from(comparer, ie ? tree_ofSeq(comparer, ie) : new SetTree(\"SetEmpty\", []));\r\n}\r\nexport function isEmpty(s) {\r\n    return tree_isEmpty(s.tree);\r\n}\r\nexport function add(item, s) {\r\n    return from(s.comparer, tree_add(s.comparer, item, s.tree));\r\n}\r\nexport function addInPlace(item, s) {\r\n    return s.has(item) ? false : (s.add(item), true);\r\n}\r\nexport function remove(item, s) {\r\n    return from(s.comparer, tree_remove(s.comparer, item, s.tree));\r\n}\r\nexport function union(set1, set2) {\r\n    return set2.tree.Case === \"SetEmpty\"\r\n        ? set1\r\n        : set1.tree.Case === \"SetEmpty\"\r\n            ? set2\r\n            : from(set1.comparer, tree_union(set1.comparer, set1.tree, set2.tree));\r\n}\r\nexport function op_Addition(set1, set2) {\r\n    return union(set1, set2);\r\n}\r\nexport function unionInPlace(set1, set2) {\r\n    seqIterate(function (x) { set1.add(x); }, set2);\r\n}\r\nexport function unionMany(sets) {\r\n    return seqFold(function (acc, s) { return union(s, acc); }, create(), sets);\r\n}\r\nexport function difference(set1, set2) {\r\n    return set1.tree.Case === \"SetEmpty\"\r\n        ? set1\r\n        : set2.tree.Case === \"SetEmpty\"\r\n            ? set1\r\n            : from(set1.comparer, tree_diff(set1.comparer, set1.tree, set2.tree));\r\n}\r\nexport function op_Subtraction(set1, set2) {\r\n    return difference(set1, set2);\r\n}\r\nexport function differenceInPlace(set1, set2) {\r\n    seqIterate(function (x) { set1.delete(x); }, set2);\r\n}\r\nexport function intersect(set1, set2) {\r\n    return set2.tree.Case === \"SetEmpty\"\r\n        ? set2\r\n        : set1.tree.Case === \"SetEmpty\"\r\n            ? set1\r\n            : from(set1.comparer, tree_intersection(set1.comparer, set1.tree, set2.tree));\r\n}\r\nexport function intersectInPlace(set1, set2) {\r\n    var set2_ = set2 instanceof Set ? set2 : new Set(set2);\r\n    seqIterate(function (x) { if (!set2_.has(x)) {\r\n        set1.delete(x);\r\n    } }, set1);\r\n}\r\nexport function intersectMany(sets) {\r\n    return seqReduce(function (s1, s2) { return intersect(s1, s2); }, sets);\r\n}\r\nexport function isProperSubsetOf(set1, set2) {\r\n    if (set1 instanceof FableSet && set2 instanceof FableSet) {\r\n        return tree_psubset(set1.comparer, set1.tree, set2.tree);\r\n    }\r\n    else {\r\n        set2 = set2 instanceof Set ? set2 : new Set(set2);\r\n        return seqForAll(function (x) { return set2.has(x); }, set1) && seqExists(function (x) { return !set1.has(x); }, set2);\r\n    }\r\n}\r\nexport function isProperSubset(set1, set2) {\r\n    return isProperSubsetOf(set1, set2);\r\n}\r\nexport function isSubsetOf(set1, set2) {\r\n    if (set1 instanceof FableSet && set2 instanceof FableSet) {\r\n        return tree_subset(set1.comparer, set1.tree, set2.tree);\r\n    }\r\n    else {\r\n        set2 = set2 instanceof Set ? set2 : new Set(set2);\r\n        return seqForAll(function (x) { return set2.has(x); }, set1);\r\n    }\r\n}\r\nexport function isSubset(set1, set2) {\r\n    return isSubsetOf(set1, set2);\r\n}\r\nexport function isProperSupersetOf(set1, set2) {\r\n    if (set1 instanceof FableSet && set2 instanceof FableSet) {\r\n        return tree_psubset(set1.comparer, set2.tree, set1.tree);\r\n    }\r\n    else {\r\n        return isProperSubset(set2 instanceof Set ? set2 : new Set(set2), set1);\r\n    }\r\n}\r\nexport function isProperSuperset(set1, set2) {\r\n    return isProperSupersetOf(set1, set2);\r\n}\r\nexport function isSupersetOf(set1, set2) {\r\n    if (set1 instanceof FableSet && set2 instanceof FableSet) {\r\n        return tree_subset(set1.comparer, set2.tree, set1.tree);\r\n    }\r\n    else {\r\n        return isSubset(set2 instanceof Set ? set2 : new Set(set2), set1);\r\n    }\r\n}\r\nexport function isSuperset(set1, set2) {\r\n    return isSupersetOf(set1, set2);\r\n}\r\nexport function copyTo(xs, arr, arrayIndex, count) {\r\n    if (!Array.isArray(arr) && !ArrayBuffer.isView(arr))\r\n        throw new Error(\"Array is invalid\");\r\n    count = count || arr.length;\r\n    var i = arrayIndex || 0;\r\n    var iter = xs[Symbol.iterator]();\r\n    while (count--) {\r\n        var el = iter.next();\r\n        if (el.done)\r\n            break;\r\n        arr[i++] = el.value;\r\n    }\r\n}\r\nexport function partition(f, s) {\r\n    if (s.tree.Case === \"SetEmpty\") {\r\n        return [s, s];\r\n    }\r\n    else {\r\n        var tuple = tree_partition(s.comparer, f, s.tree);\r\n        return [from(s.comparer, tuple[0]), from(s.comparer, tuple[1])];\r\n    }\r\n}\r\nexport function filter(f, s) {\r\n    if (s.tree.Case === \"SetEmpty\") {\r\n        return s;\r\n    }\r\n    else {\r\n        return from(s.comparer, tree_filter(s.comparer, f, s.tree));\r\n    }\r\n}\r\nexport function map(f, s) {\r\n    var comparer = new GenericComparer();\r\n    return from(comparer, tree_fold(function (acc, k) { return tree_add(comparer, f(k), acc); }, new SetTree(\"SetEmpty\", []), s.tree));\r\n}\r\nexport function exists(f, s) {\r\n    return tree_exists(f, s.tree);\r\n}\r\nexport function forAll(f, s) {\r\n    return tree_forall(f, s.tree);\r\n}\r\nexport function fold(f, seed, s) {\r\n    return tree_fold(f, seed, s.tree);\r\n}\r\nexport function foldBack(f, s, seed) {\r\n    return tree_foldBack(f, s.tree, seed);\r\n}\r\nexport function iterate(f, s) {\r\n    tree_iter(f, s.tree);\r\n}\r\nexport function minimumElement(s) {\r\n    return tree_minimumElement(s.tree);\r\n}\r\nexport function minElement(s) {\r\n    return tree_minimumElement(s.tree);\r\n}\r\nexport function maximumElement(s) {\r\n    return tree_maximumElement(s.tree);\r\n}\r\nexport function maxElement(s) {\r\n    return tree_maximumElement(s.tree);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/Set.js\n// module id = 10\n// module chunks = 0","import { toString } from \"./Util\";\r\nimport { getRestParams } from \"./Util\";\r\nimport { escape } from \"./RegExp\";\r\nimport { second } from \"./Date\";\r\nimport { minute } from \"./Date\";\r\nimport { hour } from \"./Date\";\r\nimport { day } from \"./Date\";\r\nimport { month } from \"./Date\";\r\nimport { year } from \"./Date\";\r\nvar fsFormatRegExp = /(^|[^%])%([0+ ]*)(-?\\d+)?(?:\\.(\\d+))?(\\w)/;\r\nvar formatRegExp = /\\{(\\d+)(,-?\\d+)?(?:\\:(.+?))?\\}/g;\r\nvar StringComparison = {\r\n    CurrentCulture: 0,\r\n    CurrentCultureIgnoreCase: 1,\r\n    InvariantCulture: 2,\r\n    InvariantCultureIgnoreCase: 3,\r\n    Ordinal: 4,\r\n    OrdinalIgnoreCase: 5,\r\n};\r\nfunction cmp(x, y, ic) {\r\n    function isIgnoreCase(i) {\r\n        return i === true ||\r\n            i === StringComparison.CurrentCultureIgnoreCase ||\r\n            i === StringComparison.InvariantCultureIgnoreCase ||\r\n            i === StringComparison.OrdinalIgnoreCase;\r\n    }\r\n    function isOrdinal(i) {\r\n        return i === StringComparison.Ordinal ||\r\n            i === StringComparison.OrdinalIgnoreCase;\r\n    }\r\n    if (x == null)\r\n        return y == null ? 0 : -1;\r\n    if (y == null)\r\n        return 1;\r\n    if (isOrdinal(ic)) {\r\n        if (isIgnoreCase(ic)) {\r\n            x = x.toLowerCase();\r\n            y = y.toLowerCase();\r\n        }\r\n        return (x === y) ? 0 : (x < y ? -1 : 1);\r\n    }\r\n    else {\r\n        if (isIgnoreCase(ic)) {\r\n            x = x.toLocaleLowerCase();\r\n            y = y.toLocaleLowerCase();\r\n        }\r\n        return x.localeCompare(y);\r\n    }\r\n}\r\nexport function compare() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    switch (args.length) {\r\n        case 2: return cmp(args[0], args[1], false);\r\n        case 3: return cmp(args[0], args[1], args[2]);\r\n        case 4: return cmp(args[0], args[1], args[2] === true);\r\n        case 5: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), false);\r\n        case 6: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5]);\r\n        case 7: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5] === true);\r\n        default: throw new Error(\"String.compare: Unsupported number of parameters\");\r\n    }\r\n}\r\nexport function compareTo(x, y) {\r\n    return cmp(x, y, false);\r\n}\r\nexport function indexOfAny(str, anyOf) {\r\n    var args = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        args[_i - 2] = arguments[_i];\r\n    }\r\n    if (str == null || str === \"\")\r\n        return -1;\r\n    var startIndex = (args.length > 0) ? args[0] : 0;\r\n    if (startIndex < 0)\r\n        throw new Error(\"String.indexOfAny: Start index cannot be negative\");\r\n    var length = (args.length > 1) ? args[1] : str.length - startIndex;\r\n    if (length < 0)\r\n        throw new Error(\"String.indexOfAny: Length cannot be negative\");\r\n    if (length > str.length - startIndex)\r\n        throw new Error(\"String.indexOfAny: Invalid startIndex and length\");\r\n    str = str.substr(startIndex, length);\r\n    for (var _a = 0, anyOf_1 = anyOf; _a < anyOf_1.length; _a++) {\r\n        var c = anyOf_1[_a];\r\n        var index = str.indexOf(c);\r\n        if (index > -1)\r\n            return index + startIndex;\r\n    }\r\n    return -1;\r\n}\r\nfunction toHex(value) {\r\n    return value < 0\r\n        ? \"ff\" + (16777215 - (Math.abs(value) - 1)).toString(16)\r\n        : value.toString(16);\r\n}\r\nexport function fsFormat(str) {\r\n    var args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        args[_i - 1] = arguments[_i];\r\n    }\r\n    var _cont;\r\n    function isObject(x) {\r\n        return x !== null && typeof x === \"object\" && !(x instanceof Number) && !(x instanceof String) && !(x instanceof Boolean);\r\n    }\r\n    function formatOnce(str, rep) {\r\n        return str.replace(fsFormatRegExp, function (_, prefix, flags, pad, precision, format) {\r\n            switch (format) {\r\n                case \"f\":\r\n                case \"F\":\r\n                    rep = rep.toFixed(precision || 6);\r\n                    break;\r\n                case \"g\":\r\n                case \"G\":\r\n                    rep = rep.toPrecision(precision);\r\n                    break;\r\n                case \"e\":\r\n                case \"E\":\r\n                    rep = rep.toExponential(precision);\r\n                    break;\r\n                case \"O\":\r\n                    rep = toString(rep);\r\n                    break;\r\n                case \"A\":\r\n                    try {\r\n                        rep = JSON.stringify(rep, function (k, v) {\r\n                            return v && v[Symbol.iterator] && !Array.isArray(v) && isObject(v) ? Array.from(v)\r\n                                : v && typeof v.ToString === \"function\" ? toString(v) : v;\r\n                        });\r\n                    }\r\n                    catch (err) {\r\n                        rep = \"{\" + Object.getOwnPropertyNames(rep).map(function (k) { return k + \": \" + String(rep[k]); }).join(\", \") + \"}\";\r\n                    }\r\n                    break;\r\n                case \"x\":\r\n                    rep = toHex(Number(rep));\r\n                    break;\r\n                case \"X\":\r\n                    rep = toHex(Number(rep)).toUpperCase();\r\n                    break;\r\n            }\r\n            var plusPrefix = flags.indexOf(\"+\") >= 0 && parseInt(rep) >= 0;\r\n            if (!isNaN(pad = parseInt(pad))) {\r\n                var ch = pad >= 0 && flags.indexOf(\"0\") >= 0 ? \"0\" : \" \";\r\n                rep = padLeft(rep, Math.abs(pad) - (plusPrefix ? 1 : 0), ch, pad < 0);\r\n            }\r\n            var once = prefix + (plusPrefix ? \"+\" + rep : rep);\r\n            return once.replace(/%/g, \"%%\");\r\n        });\r\n    }\r\n    function makeFn(str) {\r\n        return function (rep) {\r\n            var str2 = formatOnce(str, rep);\r\n            return fsFormatRegExp.test(str2)\r\n                ? makeFn(str2) : _cont(str2.replace(/%%/g, \"%\"));\r\n        };\r\n    }\r\n    if (args.length === 0) {\r\n        return function (cont) {\r\n            _cont = cont;\r\n            return fsFormatRegExp.test(str) ? makeFn(str) : _cont(str);\r\n        };\r\n    }\r\n    else {\r\n        for (var i = 0; i < args.length; i++) {\r\n            str = formatOnce(str, args[i]);\r\n        }\r\n        return str.replace(/%%/g, \"%\");\r\n    }\r\n}\r\nexport function format(str) {\r\n    var args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        args[_i - 1] = arguments[_i];\r\n    }\r\n    return str.replace(formatRegExp, function (match, idx, pad, format) {\r\n        var rep = args[idx], padSymbol = \" \";\r\n        if (typeof rep === \"number\") {\r\n            switch ((format || \"\").substring(0, 1)) {\r\n                case \"f\":\r\n                case \"F\":\r\n                    rep = format.length > 1 ? rep.toFixed(format.substring(1)) : rep.toFixed(2);\r\n                    break;\r\n                case \"g\":\r\n                case \"G\":\r\n                    rep = format.length > 1 ? rep.toPrecision(format.substring(1)) : rep.toPrecision();\r\n                    break;\r\n                case \"e\":\r\n                case \"E\":\r\n                    rep = format.length > 1 ? rep.toExponential(format.substring(1)) : rep.toExponential();\r\n                    break;\r\n                case \"p\":\r\n                case \"P\":\r\n                    rep = (format.length > 1 ? (rep * 100).toFixed(format.substring(1)) : (rep * 100).toFixed(2)) + \" %\";\r\n                    break;\r\n                case \"x\":\r\n                    rep = toHex(Number(rep));\r\n                    break;\r\n                case \"X\":\r\n                    rep = toHex(Number(rep)).toUpperCase();\r\n                    break;\r\n                default:\r\n                    var m = /^(0+)(\\.0+)?$/.exec(format);\r\n                    if (m != null) {\r\n                        var decs = 0;\r\n                        if (m[2] != null)\r\n                            rep = rep.toFixed(decs = m[2].length - 1);\r\n                        pad = \",\" + (m[1].length + (decs ? decs + 1 : 0)).toString();\r\n                        padSymbol = \"0\";\r\n                    }\r\n                    else if (format) {\r\n                        rep = format;\r\n                    }\r\n            }\r\n        }\r\n        else if (rep instanceof Date) {\r\n            if (format.length === 1) {\r\n                switch (format) {\r\n                    case \"D\":\r\n                        rep = rep.toDateString();\r\n                        break;\r\n                    case \"T\":\r\n                        rep = rep.toLocaleTimeString();\r\n                        break;\r\n                    case \"d\":\r\n                        rep = rep.toLocaleDateString();\r\n                        break;\r\n                    case \"t\":\r\n                        rep = rep.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\r\n                        break;\r\n                    case \"o\":\r\n                    case \"O\":\r\n                        if (rep.kind === 2) {\r\n                            var offset = rep.getTimezoneOffset() * -1;\r\n                            rep = format(\"{0:yyyy-MM-dd}T{0:HH:mm}:{1:00.000}{2}{3:00}:{4:00}\", rep, second(rep), offset >= 0 ? \"+\" : \"-\", ~~(offset / 60), offset % 60);\r\n                        }\r\n                        else {\r\n                            rep = rep.toISOString();\r\n                        }\r\n                }\r\n            }\r\n            else {\r\n                rep = format.replace(/\\w+/g, function (match2) {\r\n                    var rep2 = match2;\r\n                    switch (match2.substring(0, 1)) {\r\n                        case \"y\":\r\n                            rep2 = match2.length < 4 ? year(rep) % 100 : year(rep);\r\n                            break;\r\n                        case \"h\":\r\n                            rep2 = rep.getHours() > 12 ? hour(rep) % 12 : hour(rep);\r\n                            break;\r\n                        case \"M\":\r\n                            rep2 = month(rep);\r\n                            break;\r\n                        case \"d\":\r\n                            rep2 = day(rep);\r\n                            break;\r\n                        case \"H\":\r\n                            rep2 = hour(rep);\r\n                            break;\r\n                        case \"m\":\r\n                            rep2 = minute(rep);\r\n                            break;\r\n                        case \"s\":\r\n                            rep2 = second(rep);\r\n                            break;\r\n                    }\r\n                    if (rep2 !== match2 && rep2 < 10 && match2.length > 1) {\r\n                        rep2 = \"0\" + rep2;\r\n                    }\r\n                    return rep2;\r\n                });\r\n            }\r\n        }\r\n        if (!isNaN(pad = parseInt((pad || \"\").substring(1)))) {\r\n            rep = padLeft(rep, Math.abs(pad), padSymbol, pad < 0);\r\n        }\r\n        return rep;\r\n    });\r\n}\r\nexport function endsWith(str, search) {\r\n    var idx = str.lastIndexOf(search);\r\n    return idx >= 0 && idx == str.length - search.length;\r\n}\r\nexport function initialize(n, f) {\r\n    if (n < 0)\r\n        throw new Error(\"String length must be non-negative\");\r\n    var xs = new Array(n);\r\n    for (var i = 0; i < n; i++)\r\n        xs[i] = f(i);\r\n    return xs.join(\"\");\r\n}\r\nexport function insert(str, startIndex, value) {\r\n    if (startIndex < 0 || startIndex > str.length) {\r\n        throw new Error(\"startIndex is negative or greater than the length of this instance.\");\r\n    }\r\n    return str.substring(0, startIndex) + value + str.substring(startIndex);\r\n}\r\nexport function isNullOrEmpty(str) {\r\n    return typeof str !== \"string\" || str.length == 0;\r\n}\r\nexport function isNullOrWhiteSpace(str) {\r\n    return typeof str !== \"string\" || /^\\s*$/.test(str);\r\n}\r\nexport function join(delimiter, xs) {\r\n    xs = typeof xs == \"string\" ? getRestParams(arguments, 1) : xs;\r\n    return (Array.isArray(xs) ? xs : Array.from(xs)).join(delimiter);\r\n}\r\nexport function newGuid() {\r\n    var uuid = \"\";\r\n    for (var i = 0; i < 32; i++) {\r\n        var random = Math.random() * 16 | 0;\r\n        if (i === 8 || i === 12 || i === 16 || i === 20)\r\n            uuid += \"-\";\r\n        uuid += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);\r\n    }\r\n    return uuid;\r\n}\r\nexport function padLeft(str, len, ch, isRight) {\r\n    ch = ch || \" \";\r\n    str = String(str);\r\n    len = len - str.length;\r\n    for (var i = -1; ++i < len;)\r\n        str = isRight ? str + ch : ch + str;\r\n    return str;\r\n}\r\nexport function padRight(str, len, ch) {\r\n    return padLeft(str, len, ch, true);\r\n}\r\nexport function remove(str, startIndex, count) {\r\n    if (startIndex >= str.length) {\r\n        throw new Error(\"startIndex must be less than length of string\");\r\n    }\r\n    if (typeof count === \"number\" && (startIndex + count) > str.length) {\r\n        throw new Error(\"Index and count must refer to a location within the string.\");\r\n    }\r\n    return str.slice(0, startIndex) + (typeof count === \"number\" ? str.substr(startIndex + count) : \"\");\r\n}\r\nexport function replace(str, search, replace) {\r\n    return str.replace(new RegExp(escape(search), \"g\"), replace);\r\n}\r\nexport function replicate(n, x) {\r\n    return initialize(n, function () { return x; });\r\n}\r\nexport function split(str, splitters, count, removeEmpty) {\r\n    count = typeof count == \"number\" ? count : null;\r\n    removeEmpty = typeof removeEmpty == \"number\" ? removeEmpty : null;\r\n    if (count < 0)\r\n        throw new Error(\"Count cannot be less than zero\");\r\n    if (count === 0)\r\n        return [];\r\n    splitters = Array.isArray(splitters) ? splitters : getRestParams(arguments, 1);\r\n    splitters = splitters.map(function (x) { return escape(x); });\r\n    splitters = splitters.length > 0 ? splitters : [\" \"];\r\n    var m;\r\n    var i = 0;\r\n    var splits = [];\r\n    var reg = new RegExp(splitters.join(\"|\"), \"g\");\r\n    while ((count == null || count > 1) && (m = reg.exec(str)) !== null) {\r\n        if (!removeEmpty || (m.index - i) > 0) {\r\n            count = count != null ? count - 1 : count;\r\n            splits.push(str.substring(i, m.index));\r\n        }\r\n        i = reg.lastIndex;\r\n    }\r\n    if (!removeEmpty || (str.length - i) > 0)\r\n        splits.push(str.substring(i));\r\n    return splits;\r\n}\r\nexport function trim(str, side) {\r\n    var chars = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        chars[_i - 2] = arguments[_i];\r\n    }\r\n    if (side == \"both\" && chars.length == 0)\r\n        return str.trim();\r\n    if (side == \"start\" || side == \"both\") {\r\n        var reg = chars.length == 0 ? /^\\s+/ : new RegExp(\"^[\" + escape(chars.join(\"\")) + \"]+\");\r\n        str = str.replace(reg, \"\");\r\n    }\r\n    if (side == \"end\" || side == \"both\") {\r\n        var reg = chars.length == 0 ? /\\s+$/ : new RegExp(\"[\" + escape(chars.join(\"\")) + \"]+$\");\r\n        str = str.replace(reg, \"\");\r\n    }\r\n    return str;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/String.js\n// module id = 11\n// module chunks = 0","var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport { setType } from \"fable-core/Symbol\";\nimport _Symbol from \"fable-core/Symbol\";\nimport { Array as _Array, compareRecords, equalsRecords, Option, toString, compareUnions, equalsUnions, GenericParam } from \"fable-core/Util\";\nimport { match, isMatch, create } from \"fable-core/RegExp\";\nimport { item, toList, find, findIndex, fold } from \"fable-core/Seq\";\nimport { filter, append, map, ofArray } from \"fable-core/List\";\nimport List from \"fable-core/List\";\nimport { fsFormat } from \"fable-core/String\";\nimport { ofJson } from \"fable-core/Serialize\";\nexport var ResultF = function () {\n  function ResultF(caseName, fields) {\n    _classCallCheck(this, ResultF);\n\n    this.Case = caseName;\n    this.Fields = fields;\n  }\n\n  _createClass(ResultF, [{\n    key: _Symbol.reflection,\n    value: function () {\n      return {\n        type: \"Hmrp.HmrpEvaluator.ResultF\",\n        interfaces: [\"FSharpUnion\", \"System.IEquatable\", \"System.IComparable\"],\n        cases: {\n          ErrorF: [GenericParam(\"b\")],\n          OkF: [GenericParam(\"a\")]\n        }\n      };\n    }\n  }, {\n    key: \"Equals\",\n    value: function (other) {\n      return equalsUnions(this, other);\n    }\n  }, {\n    key: \"CompareTo\",\n    value: function (other) {\n      return compareUnions(this, other);\n    }\n  }]);\n\n  return ResultF;\n}();\nsetType(\"Hmrp.HmrpEvaluator.ResultF\", ResultF);\nexport function ResultFbind(f, result) {\n  if (result.Case === \"ErrorF\") {\n    return new ResultF(\"ErrorF\", [result.Fields[0]]);\n  } else {\n    var application = f(result.Fields[0]);\n\n    if (application.Case === \"ErrorF\") {\n      return new ResultF(\"ErrorF\", [application.Fields[0]]);\n    } else {\n      return new ResultF(\"OkF\", [application.Fields[0]]);\n    }\n  }\n}\nexport var LabelRegex = create(\"^(\\\\w+):$\");\nexport var InstructionRegex = create(\"^(\\\\s+)(\\\\w+)(\\\\s*)(\\\\w*)$\");\nexport function listToString(listOfElem) {\n  var nbElem = listOfElem.length;\n\n  if (nbElem === 0) {\n    return \"[]\";\n  } else {\n    var elemsAsString = fold(function (accum, elem) {\n      return accum + toString(elem) + \", \";\n    }, \"\", listOfElem);\n    var fixedString = elemsAsString.substr(0, elemsAsString.length - 2);\n    return \"[\" + fixedString + \"]\";\n  }\n}\nexport function maybeToString(maybeAThing) {\n  if (maybeAThing != null) {\n    return toString(maybeAThing);\n  } else {\n    return \"None\";\n  }\n}\nexport var Register = function () {\n  function Register(index, registerValue) {\n    _classCallCheck(this, Register);\n\n    this.Index = index;\n    this.RegisterValue = registerValue;\n  }\n\n  _createClass(Register, [{\n    key: _Symbol.reflection,\n    value: function () {\n      return {\n        type: \"Hmrp.HmrpEvaluator.Register\",\n        interfaces: [\"FSharpRecord\", \"System.IEquatable\", \"System.IComparable\"],\n        properties: {\n          Index: \"number\",\n          RegisterValue: Option(\"number\")\n        }\n      };\n    }\n  }, {\n    key: \"Equals\",\n    value: function (other) {\n      return equalsRecords(this, other);\n    }\n  }, {\n    key: \"CompareTo\",\n    value: function (other) {\n      return compareRecords(this, other);\n    }\n  }, {\n    key: \"ToString\",\n    value: function () {\n      return \"Register at \" + String(this.Index);\n    }\n  }]);\n\n  return Register;\n}();\nsetType(\"Hmrp.HmrpEvaluator.Register\", Register);\nexport var Label = function () {\n  function Label(name, line) {\n    _classCallCheck(this, Label);\n\n    this.Name = name;\n    this.Line = line;\n  }\n\n  _createClass(Label, [{\n    key: _Symbol.reflection,\n    value: function () {\n      return {\n        type: \"Hmrp.HmrpEvaluator.Label\",\n        interfaces: [\"FSharpRecord\", \"System.IEquatable\", \"System.IComparable\"],\n        properties: {\n          Name: \"string\",\n          Line: \"number\"\n        }\n      };\n    }\n  }, {\n    key: \"Equals\",\n    value: function (other) {\n      return equalsRecords(this, other);\n    }\n  }, {\n    key: \"CompareTo\",\n    value: function (other) {\n      return compareRecords(this, other);\n    }\n  }, {\n    key: \"ToString\",\n    value: function () {\n      return \"Label named \" + this.Name + \" at line \" + String(this.Line);\n    }\n  }]);\n\n  return Label;\n}();\nsetType(\"Hmrp.HmrpEvaluator.Label\", Label);\nexport var Instruction = function () {\n  function Instruction(caseName, fields) {\n    _classCallCheck(this, Instruction);\n\n    this.Case = caseName;\n    this.Fields = fields;\n  }\n\n  _createClass(Instruction, [{\n    key: _Symbol.reflection,\n    value: function () {\n      return {\n        type: \"Hmrp.HmrpEvaluator.Instruction\",\n        interfaces: [\"FSharpUnion\", \"System.IEquatable\", \"System.IComparable\"],\n        cases: {\n          Add: [\"number\"],\n          CopyFrom: [\"number\"],\n          CopyTo: [\"number\"],\n          Decrement: [\"number\"],\n          Inbox: [],\n          Increment: [\"number\"],\n          Jump: [\"string\"],\n          JumpIfNegative: [\"string\"],\n          JumpIfZero: [\"string\"],\n          Outbox: [],\n          Subtract: [\"number\"]\n        }\n      };\n    }\n  }, {\n    key: \"Equals\",\n    value: function (other) {\n      return equalsUnions(this, other);\n    }\n  }, {\n    key: \"CompareTo\",\n    value: function (other) {\n      return compareUnions(this, other);\n    }\n  }, {\n    key: \"ToString\",\n    value: function () {\n      if (this.Case === \"Outbox\") {\n        return \"Outbox\";\n      } else if (this.Case === \"JumpIfNegative\") {\n        return \"Jump if negative to : \" + this.Fields[0];\n      } else if (this.Case === \"JumpIfZero\") {\n        return \"Jump if zero to : \" + this.Fields[0];\n      } else if (this.Case === \"Jump\") {\n        return \"Jump to : \" + this.Fields[0];\n      } else if (this.Case === \"CopyTo\") {\n        return \"Copy to : \" + String(this.Fields[0]);\n      } else if (this.Case === \"CopyFrom\") {\n        return \"Copy from : \" + String(this.Fields[0]);\n      } else if (this.Case === \"Increment\") {\n        return \"Increment : \" + String(this.Fields[0]);\n      } else if (this.Case === \"Decrement\") {\n        return \"Decrement : \" + String(this.Fields[0]);\n      } else if (this.Case === \"Add\") {\n        return \"Add with : \" + String(this.Fields[0]);\n      } else if (this.Case === \"Subtract\") {\n        return \"Subtract with : \" + String(this.Fields[0]);\n      } else {\n        return \"Inbox\";\n      }\n    }\n  }]);\n\n  return Instruction;\n}();\nsetType(\"Hmrp.HmrpEvaluator.Instruction\", Instruction);\nexport var ProgramLine = function () {\n  function ProgramLine(caseName, fields) {\n    _classCallCheck(this, ProgramLine);\n\n    this.Case = caseName;\n    this.Fields = fields;\n  }\n\n  _createClass(ProgramLine, [{\n    key: _Symbol.reflection,\n    value: function () {\n      return {\n        type: \"Hmrp.HmrpEvaluator.ProgramLine\",\n        interfaces: [\"FSharpUnion\", \"System.IEquatable\", \"System.IComparable\"],\n        cases: {\n          InstructionLine: [Instruction],\n          LabelLine: [Label],\n          MeaningLessLine: []\n        }\n      };\n    }\n  }, {\n    key: \"Equals\",\n    value: function (other) {\n      return equalsUnions(this, other);\n    }\n  }, {\n    key: \"CompareTo\",\n    value: function (other) {\n      return compareUnions(this, other);\n    }\n  }, {\n    key: \"ToString\",\n    value: function () {\n      if (this.Case === \"InstructionLine\") {\n        return \"Line is an instruction : \" + toString(this.Fields[0]);\n      } else if (this.Case === \"LabelLine\") {\n        return \"Line is a label : \" + toString(this.Fields[0]);\n      } else {\n        return \"Line is meaningless and can be skipped\";\n      }\n    }\n  }]);\n\n  return ProgramLine;\n}();\nsetType(\"Hmrp.HmrpEvaluator.ProgramLine\", ProgramLine);\nexport var MachineState = function () {\n  function MachineState(inputs, outputs, registers, humanValue, programLines, currentInstructionLine) {\n    _classCallCheck(this, MachineState);\n\n    this.Inputs = inputs;\n    this.Outputs = outputs;\n    this.Registers = registers;\n    this.HumanValue = humanValue;\n    this.ProgramLines = programLines;\n    this.CurrentInstructionLine = currentInstructionLine;\n  }\n\n  _createClass(MachineState, [{\n    key: _Symbol.reflection,\n    value: function () {\n      return {\n        type: \"Hmrp.HmrpEvaluator.MachineState\",\n        interfaces: [\"FSharpRecord\", \"System.IEquatable\", \"System.IComparable\"],\n        properties: {\n          Inputs: _Array(Int32Array, true),\n          Outputs: _Array(Int32Array, true),\n          Registers: _Array(Register),\n          HumanValue: Option(\"number\"),\n          ProgramLines: _Array(ProgramLine),\n          CurrentInstructionLine: \"number\"\n        }\n      };\n    }\n  }, {\n    key: \"Equals\",\n    value: function (other) {\n      return equalsRecords(this, other);\n    }\n  }, {\n    key: \"CompareTo\",\n    value: function (other) {\n      return compareRecords(this, other);\n    }\n  }, {\n    key: \"ToString\",\n    value: function () {\n      var inputsAsString = listToString(ofArray(this.Inputs));\n      var outputsAsString = listToString(ofArray(this.Outputs));\n      var registersAsStringList = map(function (r) {\n        return fsFormat(\"\\n        {Index : %i, Value : %s}\")(function (x) {\n          return x;\n        })(r.Index)(maybeToString(r.RegisterValue));\n      }, ofArray(this.Registers));\n      var registersAsString = listToString(registersAsStringList);\n      var humanValueAsString = this.HumanValue != null ? String(this.HumanValue) : \"None\";\n      var result = \"State\" + \"\\n\" + \"    Inputs: \" + inputsAsString + \"\\n\" + \"    Outputs: \" + outputsAsString + \"\\n\" + \"    Registers: \" + registersAsString + \"\\n\" + \"    Human Value: \" + humanValueAsString + \"\\n\" + \"    Current Line: \" + String(this.CurrentInstructionLine);\n      return result;\n    }\n  }]);\n\n  return MachineState;\n}();\nsetType(\"Hmrp.HmrpEvaluator.MachineState\", MachineState);\nexport var InstructionEvaluationResult = function () {\n  function InstructionEvaluationResult(caseName, fields) {\n    _classCallCheck(this, InstructionEvaluationResult);\n\n    this.Case = caseName;\n    this.Fields = fields;\n  }\n\n  _createClass(InstructionEvaluationResult, [{\n    key: _Symbol.reflection,\n    value: function () {\n      return {\n        type: \"Hmrp.HmrpEvaluator.InstructionEvaluationResult\",\n        interfaces: [\"FSharpUnion\", \"System.IEquatable\", \"System.IComparable\"],\n        cases: {\n          End: [\"string\"],\n          NewState: [MachineState]\n        }\n      };\n    }\n  }, {\n    key: \"Equals\",\n    value: function (other) {\n      return equalsUnions(this, other);\n    }\n  }, {\n    key: \"CompareTo\",\n    value: function (other) {\n      return compareUnions(this, other);\n    }\n  }]);\n\n  return InstructionEvaluationResult;\n}();\nsetType(\"Hmrp.HmrpEvaluator.InstructionEvaluationResult\", InstructionEvaluationResult);\n\nfunction toInstruction(instructionName, argument, lineNumber) {\n  var instructionUpperCase = instructionName.toLocaleUpperCase();\n\n  try {\n    switch (instructionUpperCase) {\n      case \"INBOX\":\n        return new ProgramLine(\"InstructionLine\", [new Instruction(\"Inbox\", [])]);\n\n      case \"OUTBOX\":\n        return new ProgramLine(\"InstructionLine\", [new Instruction(\"Outbox\", [])]);\n\n      case \"JUMPZ\":\n        return new ProgramLine(\"InstructionLine\", [new Instruction(\"JumpIfZero\", [argument])]);\n\n      case \"JUMPN\":\n        return new ProgramLine(\"InstructionLine\", [new Instruction(\"JumpIfNegative\", [argument])]);\n\n      case \"JUMP\":\n        return new ProgramLine(\"InstructionLine\", [new Instruction(\"Jump\", [argument])]);\n\n      case \"COPYTO\":\n        var value = Number.parseInt(argument);\n        return new ProgramLine(\"InstructionLine\", [new Instruction(\"CopyTo\", [value])]);\n\n      case \"COPYFROM\":\n        var value_1 = Number.parseInt(argument);\n        return new ProgramLine(\"InstructionLine\", [new Instruction(\"CopyFrom\", [value_1])]);\n\n      case \"BUMPUP\":\n        var value_2 = Number.parseInt(argument);\n        return new ProgramLine(\"InstructionLine\", [new Instruction(\"Increment\", [value_2])]);\n\n      case \"BUMPDN\":\n        var value_3 = Number.parseInt(argument);\n        return new ProgramLine(\"InstructionLine\", [new Instruction(\"Decrement\", [value_3])]);\n\n      case \"ADD\":\n        var value_4 = Number.parseInt(argument);\n        return new ProgramLine(\"InstructionLine\", [new Instruction(\"Add\", [value_4])]);\n\n      case \"SUB\":\n        var value_5 = Number.parseInt(argument);\n        return new ProgramLine(\"InstructionLine\", [new Instruction(\"Subtract\", [value_5])]);\n\n      default:\n        return new ProgramLine(\"MeaningLessLine\", []);\n    }\n  } catch (matchValue) {\n    var argumentToString = argument != null ? argument : \"None\";\n    fsFormat(\"Cannot parse line %i which instruction is %s and argument %s.\")(function (x) {\n      console.log(x);\n    })(lineNumber)(instructionName)(argumentToString);\n    fsFormat(\"Line will be interpreted as a comment.\")(function (x) {\n      console.log(x);\n    });\n    return new ProgramLine(\"MeaningLessLine\", []);\n  }\n}\n\nfunction parseLine(line, lineNumber) {\n  var isLabel = isMatch(LabelRegex, line);\n  var isInstruction = isMatch(InstructionRegex, line);\n\n  if (isLabel) {\n    var regexMatch = match(LabelRegex, line);\n    var label = new Label(regexMatch[1], lineNumber);\n    return new ProgramLine(\"LabelLine\", [label]);\n  } else if (isInstruction) {\n    var regexMatch_1 = match(InstructionRegex, line);\n    var instructionName = regexMatch_1[2];\n    var hasArgument = regexMatch_1.length >= 4;\n    var argument = hasArgument ? regexMatch_1[4] : null;\n    return toInstruction(instructionName, argument, lineNumber);\n  } else {\n    return new ProgramLine(\"MeaningLessLine\", []);\n  }\n}\n\nfunction skipLine(machineState) {\n  var result = void 0;\n  var CurrentInstructionLine = machineState.CurrentInstructionLine + 1;\n  result = new MachineState(machineState.Inputs, machineState.Outputs, machineState.Registers, machineState.HumanValue, machineState.ProgramLines, CurrentInstructionLine);\n  return result;\n}\n\nfunction getLineIndexByLabelName(program, labelToFind) {\n  var filterFunc = function filterFunc(programLine) {\n    if (programLine.Case === \"InstructionLine\") {\n      return false;\n    } else if (programLine.Case === \"LabelLine\") {\n      return programLine.Fields[0].Name === labelToFind;\n    } else {\n      return false;\n    }\n  };\n\n  try {\n    return new ResultF(\"OkF\", [findIndex(filterFunc, program)]);\n  } catch (matchValue) {\n    return new ResultF(\"ErrorF\", [fsFormat(\"Cannot find line with the given label %s.\")(function (x) {\n      return x;\n    })(labelToFind)]);\n  }\n}\n\nfunction getRegisterByIndex(registers, registerIndex) {\n  var filterFunc = function filterFunc(register) {\n    return register.Index === registerIndex;\n  };\n\n  try {\n    return new ResultF(\"OkF\", [find(filterFunc, registers)]);\n  } catch (matchValue) {\n    return new ResultF(\"ErrorF\", [fsFormat(\"Cannot find register with the given index %i.\")(function (x) {\n      return x;\n    })(registerIndex)]);\n  }\n}\n\nfunction runInboxInstruction(machineState) {\n  if (machineState.Inputs.length > 0) {\n    var firstElemOfInput = machineState.Inputs[0];\n    var restOfInput = ofArray(machineState.Inputs).tail;\n    var result = void 0;\n    var CurrentInstructionLine = machineState.CurrentInstructionLine + 1;\n    var HumanValue = firstElemOfInput;\n    result = new MachineState(Int32Array.from(restOfInput), machineState.Outputs, machineState.Registers, HumanValue, machineState.ProgramLines, CurrentInstructionLine);\n    return new ResultF(\"OkF\", [result]);\n  } else {\n    return new ResultF(\"ErrorF\", [\"Cannot get an input because the input list is empty.\"]);\n  }\n}\n\nfunction runOutBoxInstruction(machineState) {\n  if (machineState.HumanValue == null) {\n    return new ResultF(\"ErrorF\", [\"Cannot set output since there is no value in the human register.\"]);\n  } else {\n    var newOutputs = append(ofArray(machineState.Outputs), ofArray([machineState.HumanValue]));\n    var result = void 0;\n    var CurrentInstructionLine = machineState.CurrentInstructionLine + 1;\n    var HumanValue = null;\n    var Outputs = Int32Array.from(newOutputs);\n    result = new MachineState(machineState.Inputs, Outputs, machineState.Registers, HumanValue, machineState.ProgramLines, CurrentInstructionLine);\n    return new ResultF(\"OkF\", [result]);\n  }\n}\n\nfunction runJumpIfNegativeInstruction(machineState, labelToJumpTo) {\n  if (machineState.HumanValue == null) {\n    return new ResultF(\"ErrorF\", [\"Cannot test to jump since there is no value in the human register.\"]);\n  } else {\n    var shouldJump = machineState.HumanValue < 0;\n    var nextLineIndexOrError = shouldJump ? getLineIndexByLabelName(ofArray(machineState.ProgramLines), labelToJumpTo) : new ResultF(\"OkF\", [machineState.CurrentInstructionLine + 1]);\n\n    var f = function f(nextLineIndex) {\n      return new ResultF(\"OkF\", [new MachineState(machineState.Inputs, machineState.Outputs, machineState.Registers, machineState.HumanValue, machineState.ProgramLines, nextLineIndex)]);\n    };\n\n    return ResultFbind(f, nextLineIndexOrError);\n  }\n}\n\nfunction runJumpIfZeroInstruction(machineState, labelToJumpTo) {\n  if (machineState.HumanValue == null) {\n    return new ResultF(\"ErrorF\", [\"Cannot test to jump since there is no value in the human register.\"]);\n  } else {\n    var shouldJump = machineState.HumanValue === 0;\n    var nextLineIndexOrError = shouldJump ? getLineIndexByLabelName(ofArray(machineState.ProgramLines), labelToJumpTo) : new ResultF(\"OkF\", [machineState.CurrentInstructionLine + 1]);\n\n    var f = function f(nextLineIndex) {\n      return new ResultF(\"OkF\", [new MachineState(machineState.Inputs, machineState.Outputs, machineState.Registers, machineState.HumanValue, machineState.ProgramLines, nextLineIndex)]);\n    };\n\n    return ResultFbind(f, nextLineIndexOrError);\n  }\n}\n\nfunction runJumpInstruction(machineState, labelToJumpTo) {\n  var nextLineIndexOrError = getLineIndexByLabelName(ofArray(machineState.ProgramLines), labelToJumpTo);\n\n  var f = function f(nextLineIndex) {\n    return new ResultF(\"OkF\", [new MachineState(machineState.Inputs, machineState.Outputs, machineState.Registers, machineState.HumanValue, machineState.ProgramLines, nextLineIndex)]);\n  };\n\n  return ResultFbind(f, nextLineIndexOrError);\n}\n\nfunction runCopyToInstruction(machineState, registerIndex) {\n  var oldRegisterOrError = getRegisterByIndex(ofArray(machineState.Registers), registerIndex);\n\n  var f = function f(oldRegister) {\n    if (machineState.HumanValue == null) {\n      return new ResultF(\"ErrorF\", [fsFormat(\"Cannot copy to register %i because there is no value in the human register.\")(function (x) {\n        return x;\n      })(oldRegister.Index)]);\n    } else {\n      var newRegister = void 0;\n      var RegisterValue = machineState.HumanValue;\n      newRegister = new Register(oldRegister.Index, RegisterValue);\n      var allRegisterExceptOne = filter(function (register) {\n        return !register.Equals(oldRegister);\n      }, ofArray(machineState.Registers));\n      var allRegistersUpdate = append(allRegisterExceptOne, ofArray([newRegister]));\n      return new ResultF(\"OkF\", [function () {\n        var CurrentInstructionLine = machineState.CurrentInstructionLine + 1;\n        var Registers = Array.from(allRegistersUpdate);\n        return new MachineState(machineState.Inputs, machineState.Outputs, Registers, machineState.HumanValue, machineState.ProgramLines, CurrentInstructionLine);\n      }()]);\n    }\n  };\n\n  return ResultFbind(f, oldRegisterOrError);\n}\n\nfunction runCopyFromInstruction(machineState, registerIndex) {\n  var registerOrError = getRegisterByIndex(ofArray(machineState.Registers), registerIndex);\n\n  var f = function f(register) {\n    if (register.RegisterValue == null) {\n      return new ResultF(\"ErrorF\", [fsFormat(\"Cannot copy from register %i because register has no value.\")(function (x) {\n        return x;\n      })(register.Index)]);\n    } else {\n      return new ResultF(\"OkF\", [function () {\n        var CurrentInstructionLine = machineState.CurrentInstructionLine + 1;\n        var HumanValue = register.RegisterValue;\n        return new MachineState(machineState.Inputs, machineState.Outputs, machineState.Registers, HumanValue, machineState.ProgramLines, CurrentInstructionLine);\n      }()]);\n    }\n  };\n\n  return ResultFbind(f, registerOrError);\n}\n\nfunction runAddInstruction(machineState, registerIndex) {\n  var registerOrError = getRegisterByIndex(ofArray(machineState.Registers), registerIndex);\n\n  var f = function f(register) {\n    if (register.RegisterValue == null) {\n      return new ResultF(\"ErrorF\", [fsFormat(\"Cannot add with register %i because register has no value.\")(function (x) {\n        return x;\n      })(register.Index)]);\n    } else if (machineState.HumanValue == null) {\n      return new ResultF(\"ErrorF\", [\"Cannot add with register %i because there is no value in the human register\"]);\n    } else {\n      return new ResultF(\"OkF\", [function () {\n        var CurrentInstructionLine = machineState.CurrentInstructionLine + 1;\n        var HumanValue = register.RegisterValue + machineState.HumanValue;\n        return new MachineState(machineState.Inputs, machineState.Outputs, machineState.Registers, HumanValue, machineState.ProgramLines, CurrentInstructionLine);\n      }()]);\n    }\n  };\n\n  return ResultFbind(f, registerOrError);\n}\n\nfunction runSubtractInstruction(machineState, registerIndex) {\n  var registerOrError = getRegisterByIndex(ofArray(machineState.Registers), registerIndex);\n\n  var f = function f(register) {\n    if (register.RegisterValue == null) {\n      return new ResultF(\"ErrorF\", [fsFormat(\"Cannot subtract from register %i because register has no value.\")(function (x) {\n        return x;\n      })(register.Index)]);\n    } else if (machineState.HumanValue == null) {\n      return new ResultF(\"ErrorF\", [\"Cannot add with register %i because there is no value in the human register\"]);\n    } else {\n      return new ResultF(\"OkF\", [function () {\n        var CurrentInstructionLine = machineState.CurrentInstructionLine + 1;\n        var HumanValue = machineState.HumanValue - register.RegisterValue;\n        return new MachineState(machineState.Inputs, machineState.Outputs, machineState.Registers, HumanValue, machineState.ProgramLines, CurrentInstructionLine);\n      }()]);\n    }\n  };\n\n  return ResultFbind(f, registerOrError);\n}\n\nfunction runIncrementInstruction(machineState, registerIndex) {\n  var oldRegisterOrError = getRegisterByIndex(ofArray(machineState.Registers), registerIndex);\n\n  var f = function f(oldRegister) {\n    if (oldRegister.RegisterValue == null) {\n      return new ResultF(\"ErrorF\", [fsFormat(\"Cannot increment from register %i because register has no value.\")(function (x) {\n        return x;\n      })(oldRegister.Index)]);\n    } else {\n      var newValue = oldRegister.RegisterValue + 1;\n      var newRegister = void 0;\n      var RegisterValue = newValue;\n      newRegister = new Register(oldRegister.Index, RegisterValue);\n      var allRegisterExceptOne = filter(function (register) {\n        return !register.Equals(oldRegister);\n      }, ofArray(machineState.Registers));\n      var allRegistersUpdate = append(allRegisterExceptOne, ofArray([newRegister]));\n      return new ResultF(\"OkF\", [function () {\n        var CurrentInstructionLine = machineState.CurrentInstructionLine + 1;\n        var Registers = Array.from(allRegistersUpdate);\n        var HumanValue = newValue;\n        return new MachineState(machineState.Inputs, machineState.Outputs, Registers, HumanValue, machineState.ProgramLines, CurrentInstructionLine);\n      }()]);\n    }\n  };\n\n  return ResultFbind(f, oldRegisterOrError);\n}\n\nfunction runDecrementInstruction(machineState, registerIndex) {\n  var oldRegisterOrError = getRegisterByIndex(ofArray(machineState.Registers), registerIndex);\n\n  var f = function f(oldRegister) {\n    if (oldRegister.RegisterValue == null) {\n      return new ResultF(\"ErrorF\", [fsFormat(\"Cannot increment from register %i because register has no value.\")(function (x) {\n        return x;\n      })(oldRegister.Index)]);\n    } else {\n      var newValue = oldRegister.RegisterValue - 1;\n      var newRegister = void 0;\n      var RegisterValue = newValue;\n      newRegister = new Register(oldRegister.Index, RegisterValue);\n      var allRegisterExceptOne = filter(function (register) {\n        return !register.Equals(oldRegister);\n      }, ofArray(machineState.Registers));\n      var allRegistersUpdate = append(allRegisterExceptOne, ofArray([newRegister]));\n      return new ResultF(\"OkF\", [function () {\n        var CurrentInstructionLine = machineState.CurrentInstructionLine + 1;\n        var Registers = Array.from(allRegistersUpdate);\n        var HumanValue = newValue;\n        return new MachineState(machineState.Inputs, machineState.Outputs, Registers, HumanValue, machineState.ProgramLines, CurrentInstructionLine);\n      }()]);\n    }\n  };\n\n  return ResultFbind(f, oldRegisterOrError);\n}\n\nexport function runInstruction(machineState, instruction) {\n  var nextStep = instruction.Case === \"Outbox\" ? runOutBoxInstruction(machineState) : instruction.Case === \"JumpIfNegative\" ? runJumpIfNegativeInstruction(machineState, instruction.Fields[0]) : instruction.Case === \"JumpIfZero\" ? runJumpIfZeroInstruction(machineState, instruction.Fields[0]) : instruction.Case === \"Jump\" ? runJumpInstruction(machineState, instruction.Fields[0]) : instruction.Case === \"CopyTo\" ? runCopyToInstruction(machineState, instruction.Fields[0]) : instruction.Case === \"CopyFrom\" ? runCopyFromInstruction(machineState, instruction.Fields[0]) : instruction.Case === \"Add\" ? runAddInstruction(machineState, instruction.Fields[0]) : instruction.Case === \"Subtract\" ? runSubtractInstruction(machineState, instruction.Fields[0]) : instruction.Case === \"Increment\" ? runIncrementInstruction(machineState, instruction.Fields[0]) : instruction.Case === \"Decrement\" ? runDecrementInstruction(machineState, instruction.Fields[0]) : runInboxInstruction(machineState);\n\n  if (nextStep.Case === \"OkF\") {\n    return new InstructionEvaluationResult(\"NewState\", [nextStep.Fields[0]]);\n  } else {\n    return new InstructionEvaluationResult(\"End\", [nextStep.Fields[0]]);\n  }\n}\nexport function runStep(machineState) {\n  if (machineState.CurrentInstructionLine < machineState.ProgramLines.length) {\n    var currentInstruction = machineState.ProgramLines[machineState.CurrentInstructionLine];\n    var result = currentInstruction.Case === \"LabelLine\" ? new InstructionEvaluationResult(\"NewState\", [skipLine(machineState)]) : currentInstruction.Case === \"InstructionLine\" ? runInstruction(machineState, currentInstruction.Fields[0]) : new InstructionEvaluationResult(\"NewState\", [skipLine(machineState)]);\n    return result;\n  } else {\n    return new InstructionEvaluationResult(\"End\", [\"There is no more line to run.\"]);\n  }\n}\nexport function printState(state) {\n  var stateToString = toString(state);\n  fsFormat(\"%s\\n\")(function (x) {\n    console.log(x);\n  })(stateToString);\n}\nexport function printStates(states) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = states[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var state = _step.value;\n      printState(state);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\nexport function stringArrayToProgramList(lines) {\n  var results = [];\n\n  for (var i = 0; i <= lines.length - 1; i++) {\n    var line = lines[i];\n    var result = parseLine(line, i);\n    results.push(result);\n  }\n\n  var returnedValue = toList(results);\n  return returnedValue;\n}\nexport function stringListToProgramList(lines) {\n  var results = [];\n\n  for (var i = 0; i <= lines.length - 1; i++) {\n    var line = item(i, lines);\n    var result = parseLine(line, i);\n    results.push(result);\n  }\n\n  var returnedValue = toList(results);\n  return returnedValue;\n}\nexport var defaultMachineState = new MachineState(new Int32Array([]), new Int32Array([]), [], null, [], 0);\nexport function buildEmptyRegisters(nbOfRegisters) {\n  var registers = new List();\n\n  for (var i = 0; i <= nbOfRegisters; i++) {\n    var newRegister = new Register(i, null);\n    registers = append(registers, ofArray([newRegister]));\n  }\n\n  return registers;\n}\nexport function printProgramLines(programLines) {\n  var i = 1;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = programLines[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var result = _step2.value;\n      fsFormat(\"Line %i %s\")(function (x) {\n        console.log(x);\n      })(i)(toString(result));\n      i = i + 1;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\nexport function runFirstStep(input) {\n  var lines = ofJson(input.lines, {\n    T: _Array(\"string\")\n  });\n  var registers = ofJson(input.registers, {\n    T: _Array(Register)\n  });\n  var inputs = ofJson(input.inputs, {\n    T: _Array(Int32Array, true)\n  });\n  var parsedLines = stringListToProgramList(toList(lines));\n  var programInitialState = defaultMachineState;\n  var state = void 0;\n  var ProgramLines = Array.from(parsedLines);\n  state = new MachineState(inputs, programInitialState.Outputs, registers, programInitialState.HumanValue, ProgramLines, programInitialState.CurrentInstructionLine);\n  var nextStepResult = runStep(state);\n  return nextStepResult;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./output/hmrpEvaluator.js\n// module id = 12\n// module chunks = 0","export function addRangeInPlace(range, xs) {\r\n    var iter = range[Symbol.iterator]();\r\n    var cur = iter.next();\r\n    while (!cur.done) {\r\n        xs.push(cur.value);\r\n        cur = iter.next();\r\n    }\r\n}\r\nexport function copyTo(source, sourceIndex, target, targetIndex, count) {\r\n    while (count--)\r\n        target[targetIndex++] = source[sourceIndex++];\r\n}\r\nexport function partition(f, xs) {\r\n    var ys = [], zs = [], j = 0, k = 0;\r\n    for (var i = 0; i < xs.length; i++)\r\n        if (f(xs[i]))\r\n            ys[j++] = xs[i];\r\n        else\r\n            zs[k++] = xs[i];\r\n    return [ys, zs];\r\n}\r\nexport function permute(f, xs) {\r\n    var ys = xs.map(function () { return null; });\r\n    var checkFlags = new Array(xs.length);\r\n    for (var i = 0; i < xs.length; i++) {\r\n        var j = f(i);\r\n        if (j < 0 || j >= xs.length)\r\n            throw new Error(\"Not a valid permutation\");\r\n        ys[j] = xs[i];\r\n        checkFlags[j] = 1;\r\n    }\r\n    for (var i = 0; i < xs.length; i++)\r\n        if (checkFlags[i] != 1)\r\n            throw new Error(\"Not a valid permutation\");\r\n    return ys;\r\n}\r\nexport function removeInPlace(item, xs) {\r\n    var i = xs.indexOf(item);\r\n    if (i > -1) {\r\n        xs.splice(i, 1);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexport function setSlice(target, lower, upper, source) {\r\n    var length = (upper || target.length - 1) - lower;\r\n    if (ArrayBuffer.isView(target) && source.length <= length)\r\n        target.set(source, lower);\r\n    else\r\n        for (var i = lower | 0, j = 0; j <= length; i++, j++)\r\n            target[i] = source[j];\r\n}\r\nexport function sortInPlaceBy(f, xs, dir) {\r\n    if (dir === void 0) { dir = 1; }\r\n    return xs.sort(function (x, y) {\r\n        x = f(x);\r\n        y = f(y);\r\n        return (x < y ? -1 : x == y ? 0 : 1) * dir;\r\n    });\r\n}\r\nexport function unzip(xs) {\r\n    var bs = new Array(xs.length), cs = new Array(xs.length);\r\n    for (var i = 0; i < xs.length; i++) {\r\n        bs[i] = xs[i][0];\r\n        cs[i] = xs[i][1];\r\n    }\r\n    return [bs, cs];\r\n}\r\nexport function unzip3(xs) {\r\n    var bs = new Array(xs.length), cs = new Array(xs.length), ds = new Array(xs.length);\r\n    for (var i = 0; i < xs.length; i++) {\r\n        bs[i] = xs[i][0];\r\n        cs[i] = xs[i][1];\r\n        ds[i] = xs[i][2];\r\n    }\r\n    return [bs, cs, ds];\r\n}\r\nexport function getSubArray(xs, startIndex, count) {\r\n    return xs.slice(startIndex, startIndex + count);\r\n}\r\nexport function fill(target, targetIndex, count, value) {\r\n    target.fill(value, targetIndex, targetIndex + count);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/Array.js\n// module id = 13\n// module chunks = 0","import { NonDeclaredType, getPropertyNames, getDefinition } from \"./Util\";\r\nimport List from \"./List\";\r\nimport FSymbol from \"./Symbol\";\r\nvar MemberInfo = (function () {\r\n    function MemberInfo(name, index, declaringType, propertyType, unionFields) {\r\n        this.name = name;\r\n        this.index = index;\r\n        this.declaringType = declaringType;\r\n        this.propertyType = propertyType;\r\n        this.unionFields = unionFields;\r\n    }\r\n    MemberInfo.prototype.getUnionFields = function () {\r\n        var _this = this;\r\n        return this.unionFields.map(function (fi, i) { return new MemberInfo(\"unknown\", i, _this.declaringType, fi); });\r\n    };\r\n    return MemberInfo;\r\n}());\r\nexport { MemberInfo };\r\nexport function resolveGeneric(idx, enclosing) {\r\n    try {\r\n        var t = enclosing.head;\r\n        if (t.generics == null) {\r\n            return resolveGeneric(idx, enclosing.tail);\r\n        }\r\n        else {\r\n            var name_1 = typeof idx === \"string\"\r\n                ? idx : Object.getOwnPropertyNames(t.generics)[idx];\r\n            var resolved = t.generics[name_1];\r\n            if (resolved == null) {\r\n                return resolveGeneric(idx, enclosing.tail);\r\n            }\r\n            else if (resolved instanceof NonDeclaredType && resolved.kind === \"GenericParam\") {\r\n                return resolveGeneric(resolved.definition, enclosing.tail);\r\n            }\r\n            else {\r\n                return new List(resolved, enclosing);\r\n            }\r\n        }\r\n    }\r\n    catch (err) {\r\n        throw new Error(\"Cannot resolve generic argument \" + idx + \": \" + err);\r\n    }\r\n}\r\nexport function getType(obj) {\r\n    var t = typeof obj;\r\n    switch (t) {\r\n        case \"boolean\":\r\n        case \"number\":\r\n        case \"string\":\r\n        case \"function\":\r\n            return t;\r\n        default:\r\n            return Object.getPrototypeOf(obj).constructor;\r\n    }\r\n}\r\nexport function getTypeFullName(typ, option) {\r\n    function trim(fullName, option) {\r\n        if (typeof fullName !== \"string\") {\r\n            return \"unknown\";\r\n        }\r\n        if (option === \"name\") {\r\n            var i = fullName.lastIndexOf('.');\r\n            return fullName.substr(i + 1);\r\n        }\r\n        if (option === \"namespace\") {\r\n            var i = fullName.lastIndexOf('.');\r\n            return i > -1 ? fullName.substr(0, i) : \"\";\r\n        }\r\n        return fullName;\r\n    }\r\n    if (typeof typ === \"string\") {\r\n        return typ;\r\n    }\r\n    else if (typ instanceof NonDeclaredType) {\r\n        switch (typ.kind) {\r\n            case \"Unit\":\r\n                return \"unit\";\r\n            case \"Option\":\r\n                return getTypeFullName(typ.generics, option) + \" option\";\r\n            case \"Array\":\r\n                return getTypeFullName(typ.generics, option) + \"[]\";\r\n            case \"Tuple\":\r\n                return typ.generics.map(function (x) { return getTypeFullName(x, option); }).join(\" * \");\r\n            case \"GenericParam\":\r\n            case \"Interface\":\r\n                return typ.definition;\r\n            case \"GenericType\":\r\n                return getTypeFullName(typ.definition, option);\r\n            case \"Any\":\r\n            default:\r\n                return \"unknown\";\r\n        }\r\n    }\r\n    else {\r\n        var proto = typ.prototype;\r\n        return trim(typeof proto[FSymbol.reflection] === \"function\"\r\n            ? proto[FSymbol.reflection]().type : null, option);\r\n    }\r\n}\r\nexport function getName(x) {\r\n    if (x instanceof MemberInfo) {\r\n        return x.name;\r\n    }\r\n    return getTypeFullName(x, \"name\");\r\n}\r\nexport function getPrototypeOfType(typ) {\r\n    if (typeof typ === \"string\") {\r\n        return null;\r\n    }\r\n    else if (typ instanceof NonDeclaredType) {\r\n        return typ.kind === \"GenericType\" ? typ.definition.prototype : null;\r\n    }\r\n    else {\r\n        return typ.prototype;\r\n    }\r\n}\r\nexport function getProperties(typ) {\r\n    var proto = getPrototypeOfType(typ);\r\n    if (proto != null && typeof proto[FSymbol.reflection] === \"function\") {\r\n        var info_1 = proto[FSymbol.reflection]();\r\n        if (info_1.properties) {\r\n            return Object.getOwnPropertyNames(info_1.properties)\r\n                .map(function (k, i) { return new MemberInfo(k, i, typ, info_1.properties[k]); });\r\n        }\r\n    }\r\n    throw new Error(\"Type \" + getTypeFullName(typ) + \" doesn't contain property info.\");\r\n}\r\nexport function getUnionCases(typ) {\r\n    var proto = getPrototypeOfType(typ);\r\n    if (proto != null && typeof proto[FSymbol.reflection] === \"function\") {\r\n        var info_2 = proto[FSymbol.reflection]();\r\n        if (info_2.cases) {\r\n            return Object.getOwnPropertyNames(info_2.cases)\r\n                .map(function (k, i) { return new MemberInfo(k, i, typ, null, info_2.cases[k]); });\r\n        }\r\n    }\r\n    throw new Error(\"Type \" + getTypeFullName(typ) + \" doesn't contain union case info.\");\r\n}\r\nexport function getPropertyValues(obj) {\r\n    return getPropertyNames(obj).map(function (k) { return obj[k]; });\r\n}\r\nexport function getUnionFields(obj, typ) {\r\n    if (obj != null && typeof obj[FSymbol.reflection] === \"function\") {\r\n        var info = obj[FSymbol.reflection]();\r\n        if (info.cases) {\r\n            var uci = null, cases = Object.getOwnPropertyNames(info.cases);\r\n            for (var i = 0; i < cases.length; i++) {\r\n                if (cases[i] === obj.Case) {\r\n                    uci = new MemberInfo(cases[i], i, typ, null, info.cases[cases[i]]);\r\n                    break;\r\n                }\r\n            }\r\n            if (uci != null) {\r\n                return [uci, obj.Fields];\r\n            }\r\n        }\r\n    }\r\n    throw new Error(\"Not an F# union type.\");\r\n}\r\nexport function makeUnion(caseInfo, args) {\r\n    var Cons = getDefinition(caseInfo.declaringType);\r\n    return new (Cons.bind.apply(Cons, [void 0, caseInfo.name].concat(args)))();\r\n}\r\nexport function getTupleElements(typ) {\r\n    if (typ instanceof NonDeclaredType && typ.kind === \"Tuple\") {\r\n        return typ.generics;\r\n    }\r\n    throw new Error(\"Type \" + getTypeFullName(typ) + \" is not a tuple type.\");\r\n}\r\nexport function isTupleType(typ) {\r\n    if (typ instanceof NonDeclaredType) {\r\n        return typ.kind === \"Tuple\";\r\n    }\r\n    return false;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/Reflection.js\n// module id = 14\n// module chunks = 0","import FableSymbol from \"./Symbol\";\r\nimport { getType } from \"./Symbol\";\r\nimport List from \"./List\";\r\nimport { ofArray as listOfArray } from \"./List\";\r\nimport FableSet from \"./Set\";\r\nimport FableMap from \"./Map\";\r\nimport { create as mapCreate } from \"./Map\";\r\nimport { create as setCreate } from \"./Set\";\r\nimport { hasInterface } from \"./Util\";\r\nimport { getDefinition } from \"./Util\";\r\nimport { NonDeclaredType } from \"./Util\";\r\nimport { fold } from \"./Seq\";\r\nimport { resolveGeneric, getTypeFullName } from \"./Reflection\";\r\nimport { parse as dateParse } from \"./Date\";\r\nimport { fsFormat } from \"./String\";\r\nexport function toJson(o) {\r\n    return JSON.stringify(o, function (k, v) {\r\n        if (ArrayBuffer.isView(v)) {\r\n            return Array.from(v);\r\n        }\r\n        else if (v != null && typeof v === \"object\") {\r\n            var properties = typeof v[FableSymbol.reflection] === \"function\" ? v[FableSymbol.reflection]().properties : null;\r\n            if (v instanceof List || v instanceof FableSet || v instanceof Set) {\r\n                return Array.from(v);\r\n            }\r\n            else if (v instanceof FableMap || v instanceof Map) {\r\n                var stringKeys_1 = null;\r\n                return fold(function (o, kv) {\r\n                    if (stringKeys_1 === null) {\r\n                        stringKeys_1 = typeof kv[0] === \"string\";\r\n                    }\r\n                    o[stringKeys_1 ? kv[0] : toJson(kv[0])] = kv[1];\r\n                    return o;\r\n                }, {}, v);\r\n            }\r\n            else if (!hasInterface(v, \"FSharpRecord\") && properties) {\r\n                return fold(function (o, prop) {\r\n                    return o[prop] = v[prop], o;\r\n                }, {}, Object.getOwnPropertyNames(properties));\r\n            }\r\n            else if (hasInterface(v, \"FSharpUnion\")) {\r\n                if (!v.Fields || !v.Fields.length) {\r\n                    return v.Case;\r\n                }\r\n                else if (v.Fields.length === 1) {\r\n                    var fieldValue = typeof v.Fields[0] === 'undefined' ? null : v.Fields[0];\r\n                    return _a = {}, _a[v.Case] = fieldValue, _a;\r\n                }\r\n                else {\r\n                    return _b = {}, _b[v.Case] = v.Fields, _b;\r\n                }\r\n            }\r\n        }\r\n        return v;\r\n        var _a, _b;\r\n    });\r\n}\r\nfunction combine(path1, path2) {\r\n    return typeof path2 === \"number\"\r\n        ? path1 + \"[\" + path2 + \"]\"\r\n        : (path1 ? path1 + \".\" : \"\") + path2;\r\n}\r\nfunction isNullable(typ) {\r\n    if (typeof typ === \"string\") {\r\n        return typ !== \"boolean\" && typ !== \"number\";\r\n    }\r\n    else if (typ instanceof NonDeclaredType) {\r\n        return typ.kind !== \"Array\" && typ.kind !== \"Tuple\";\r\n    }\r\n    else {\r\n        var info = typeof typ.prototype[FableSymbol.reflection] === \"function\"\r\n            ? typ.prototype[FableSymbol.reflection]() : null;\r\n        return info ? info.nullable : true;\r\n    }\r\n}\r\nfunction invalidate(val, typ, path) {\r\n    throw new Error(fsFormat(\"%A\", val) + \" \" + (path ? \"(\" + path + \")\" : \"\") + \" is not of type \" + getTypeFullName(typ));\r\n}\r\nfunction needsInflate(enclosing) {\r\n    var typ = enclosing.head;\r\n    if (typeof typ === \"string\") {\r\n        return false;\r\n    }\r\n    if (typ instanceof NonDeclaredType) {\r\n        switch (typ.kind) {\r\n            case \"Option\":\r\n            case \"Array\":\r\n                return typ.definition != null || needsInflate(new List(typ.generics, enclosing));\r\n            case \"Tuple\":\r\n                return typ.generics.some(function (x) {\r\n                    return needsInflate(new List(x, enclosing));\r\n                });\r\n            case \"GenericParam\":\r\n                return needsInflate(resolveGeneric(typ.definition, enclosing.tail));\r\n            case \"GenericType\":\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction inflateArray(arr, enclosing, path) {\r\n    if (!Array.isArray) {\r\n        invalidate(arr, \"array\", path);\r\n    }\r\n    return needsInflate(enclosing)\r\n        ? arr.map(function (x, i) { return inflate(x, enclosing, combine(path, i)); })\r\n        : arr;\r\n}\r\nfunction inflateMap(obj, keyEnclosing, valEnclosing, path) {\r\n    var inflateKey = keyEnclosing.head !== \"string\";\r\n    var inflateVal = needsInflate(valEnclosing);\r\n    return Object\r\n        .getOwnPropertyNames(obj)\r\n        .map(function (k) {\r\n        var key = inflateKey ? inflate(JSON.parse(k), keyEnclosing, combine(path, k)) : k;\r\n        var val = inflateVal ? inflate(obj[k], valEnclosing, combine(path, k)) : obj[k];\r\n        return [key, val];\r\n    });\r\n}\r\nfunction inflateList(val, enclosing, path) {\r\n    var ar = [], li = new List(), cur = val, inf = needsInflate(enclosing);\r\n    while (cur.tail != null) {\r\n        ar.push(inf ? inflate(cur.head, enclosing, path) : cur.head);\r\n        cur = cur.tail;\r\n    }\r\n    ar.reverse();\r\n    for (var i = 0; i < ar.length; i++) {\r\n        li = new List(ar[i], li);\r\n    }\r\n    return li;\r\n}\r\nfunction inflate(val, typ, path) {\r\n    var enclosing = null;\r\n    if (typ instanceof List) {\r\n        enclosing = typ;\r\n        typ = typ.head;\r\n    }\r\n    else {\r\n        enclosing = new List(typ, new List());\r\n    }\r\n    if (val == null) {\r\n        if (!isNullable(typ)) {\r\n            invalidate(val, typ, path);\r\n        }\r\n        return val;\r\n    }\r\n    else if (typeof typ === \"string\") {\r\n        if ((typ === \"boolean\" || typ === \"number\" || typ === \"string\") && (typeof val !== typ)) {\r\n            invalidate(val, typ, path);\r\n        }\r\n        return val;\r\n    }\r\n    else if (typ instanceof NonDeclaredType) {\r\n        switch (typ.kind) {\r\n            case \"Unit\":\r\n                return null;\r\n            case \"Option\":\r\n                return inflate(val, new List(typ.generics, enclosing), path);\r\n            case \"Array\":\r\n                if (typ.definition != null) {\r\n                    return new typ.definition(val);\r\n                }\r\n                else {\r\n                    return inflateArray(val, new List(typ.generics, enclosing), path);\r\n                }\r\n            case \"Tuple\":\r\n                return typ.generics.map(function (x, i) {\r\n                    return inflate(val[i], new List(x, enclosing), combine(path, i));\r\n                });\r\n            case \"GenericParam\":\r\n                return inflate(val, resolveGeneric(typ.definition, enclosing.tail), path);\r\n            case \"GenericType\":\r\n                var def = typ.definition;\r\n                if (def === List) {\r\n                    return Array.isArray(val)\r\n                        ? listOfArray(inflateArray(val, resolveGeneric(0, enclosing), path))\r\n                        : inflateList(val, resolveGeneric(0, enclosing), path);\r\n                }\r\n                if (def === FableSet) {\r\n                    return setCreate(inflateArray(val, resolveGeneric(0, enclosing), path));\r\n                }\r\n                if (def === Set) {\r\n                    return new Set(inflateArray(val, resolveGeneric(0, enclosing), path));\r\n                }\r\n                if (def === FableMap) {\r\n                    return mapCreate(inflateMap(val, resolveGeneric(0, enclosing), resolveGeneric(1, enclosing), path));\r\n                }\r\n                if (def === Map) {\r\n                    return new Map(inflateMap(val, resolveGeneric(0, enclosing), resolveGeneric(1, enclosing), path));\r\n                }\r\n                return inflate(val, new List(typ.definition, enclosing), path);\r\n            default:\r\n                return val;\r\n        }\r\n    }\r\n    else if (typeof typ === \"function\") {\r\n        if (typ === Date) {\r\n            return dateParse(val);\r\n        }\r\n        var info = typeof typ.prototype[FableSymbol.reflection] === \"function\" ? typ.prototype[FableSymbol.reflection]() : {};\r\n        if (info.cases) {\r\n            var uCase = void 0, uFields = [];\r\n            if (typeof val === \"string\") {\r\n                uCase = val;\r\n            }\r\n            else if (typeof val.Case === \"string\" && Array.isArray(val.Fields)) {\r\n                uCase = val.Case;\r\n                uFields = val.Fields;\r\n            }\r\n            else {\r\n                var caseName = Object.getOwnPropertyNames(val)[0];\r\n                var fieldTypes = info.cases[caseName];\r\n                if (Array.isArray(fieldTypes)) {\r\n                    var fields = fieldTypes.length > 1 ? val[caseName] : [val[caseName]];\r\n                    uCase = caseName;\r\n                    path = combine(path, caseName);\r\n                    for (var i = 0; i < fieldTypes.length; i++) {\r\n                        uFields.push(inflate(fields[i], new List(fieldTypes[i], enclosing), combine(path, i)));\r\n                    }\r\n                }\r\n            }\r\n            if (uCase in info.cases === false) {\r\n                invalidate(val, typ, path);\r\n            }\r\n            return new typ(uCase, uFields);\r\n        }\r\n        if (info.properties) {\r\n            var newObj = new typ();\r\n            var properties = info.properties;\r\n            var ks = Object.getOwnPropertyNames(properties);\r\n            for (var i = 0; i < ks.length; i++) {\r\n                var k = ks[i];\r\n                newObj[k] = inflate(val[k], new List(properties[k], enclosing), combine(path, k));\r\n            }\r\n            return newObj;\r\n        }\r\n        return val;\r\n    }\r\n    throw new Error(\"Unexpected type when deserializing JSON: \" + typ);\r\n}\r\nfunction inflatePublic(val, genArgs) {\r\n    return inflate(val, genArgs ? genArgs.T : null, \"\");\r\n}\r\nexport { inflatePublic as inflate };\r\nexport function ofJson(json, genArgs) {\r\n    return inflate(JSON.parse(json), genArgs ? genArgs.T : null, \"\");\r\n}\r\nexport function toJsonWithTypeInfo(o) {\r\n    return JSON.stringify(o, function (k, v) {\r\n        if (ArrayBuffer.isView(v)) {\r\n            return Array.from(v);\r\n        }\r\n        else if (v != null && typeof v === \"object\") {\r\n            var typeName = typeof v[FableSymbol.reflection] === \"function\" ? v[FableSymbol.reflection]().type : null;\r\n            if (v instanceof List || v instanceof FableSet || v instanceof Set) {\r\n                return {\r\n                    $type: typeName || \"System.Collections.Generic.HashSet\",\r\n                    $values: Array.from(v)\r\n                };\r\n            }\r\n            else if (v instanceof FableMap || v instanceof Map) {\r\n                return fold(function (o, kv) { o[kv[0]] = kv[1]; return o; }, { $type: typeName || \"System.Collections.Generic.Dictionary\" }, v);\r\n            }\r\n            else if (typeName) {\r\n                if (hasInterface(v, \"FSharpUnion\") || hasInterface(v, \"FSharpRecord\")) {\r\n                    return Object.assign({ $type: typeName }, v);\r\n                }\r\n                else {\r\n                    var proto = Object.getPrototypeOf(v), props = Object.getOwnPropertyNames(proto), o_1 = { $type: typeName };\r\n                    for (var i = 0; i < props.length; i++) {\r\n                        var prop = Object.getOwnPropertyDescriptor(proto, props[i]);\r\n                        if (prop.get)\r\n                            o_1[props[i]] = prop.get.apply(v);\r\n                    }\r\n                    return o_1;\r\n                }\r\n            }\r\n        }\r\n        return v;\r\n    });\r\n}\r\nexport function ofJsonWithTypeInfo(json, genArgs) {\r\n    var parsed = JSON.parse(json, function (k, v) {\r\n        if (v == null)\r\n            return v;\r\n        else if (typeof v === \"object\" && typeof v.$type === \"string\") {\r\n            var type = v.$type.replace('+', '.'), i = type.indexOf('`');\r\n            if (i > -1) {\r\n                type = type.substr(0, i);\r\n            }\r\n            else {\r\n                i = type.indexOf(',');\r\n                type = i > -1 ? type.substr(0, i) : type;\r\n            }\r\n            if (type === \"System.Collections.Generic.List\" || (type.indexOf(\"[]\") === type.length - 2)) {\r\n                return v.$values;\r\n            }\r\n            if (type === \"Microsoft.FSharp.Collections.FSharpList\") {\r\n                return listOfArray(v.$values);\r\n            }\r\n            else if (type == \"Microsoft.FSharp.Collections.FSharpSet\") {\r\n                return setCreate(v.$values);\r\n            }\r\n            else if (type == \"System.Collections.Generic.HashSet\") {\r\n                return new Set(v.$values);\r\n            }\r\n            else if (type == \"Microsoft.FSharp.Collections.FSharpMap\") {\r\n                delete v.$type;\r\n                return mapCreate(Object.getOwnPropertyNames(v)\r\n                    .map(function (k) { return [k, v[k]]; }));\r\n            }\r\n            else if (type == \"System.Collections.Generic.Dictionary\") {\r\n                delete v.$type;\r\n                return new Map(Object.getOwnPropertyNames(v)\r\n                    .map(function (k) { return [k, v[k]]; }));\r\n            }\r\n            else {\r\n                var T = getType(type);\r\n                if (T) {\r\n                    delete v.$type;\r\n                    return Object.assign(new T(), v);\r\n                }\r\n            }\r\n        }\r\n        else if (/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:[+-]\\d{2}:\\d{2}|Z)$/.test(v))\r\n            return dateParse(v);\r\n        else\r\n            return v;\r\n    });\r\n    var expected = genArgs ? genArgs.T : null;\r\n    if (parsed != null && typeof expected === \"function\"\r\n        && !(parsed instanceof getDefinition(expected))) {\r\n        throw new Error(\"JSON is not of type \" + expected.name + \": \" + json);\r\n    }\r\n    return parsed;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/Serialize.js\n// module id = 15\n// module chunks = 0","import { compare as utilCompare } from \"./Util\";\r\nimport * as Long from \"./Long\";\r\nexport function create(d, h, m, s, ms) {\r\n    if (d === void 0) { d = 0; }\r\n    if (h === void 0) { h = 0; }\r\n    if (m === void 0) { m = 0; }\r\n    if (s === void 0) { s = 0; }\r\n    if (ms === void 0) { ms = 0; }\r\n    switch (arguments.length) {\r\n        case 1:\r\n            return fromTicks(arguments[0]);\r\n        case 3:\r\n            d = 0, h = arguments[0], m = arguments[1], s = arguments[2], ms = 0;\r\n            break;\r\n        default:\r\n            d = arguments[0], h = arguments[1], m = arguments[2], s = arguments[3], ms = arguments[4] || 0;\r\n            break;\r\n    }\r\n    return d * 86400000 + h * 3600000 + m * 60000 + s * 1000 + ms;\r\n}\r\nexport function fromTicks(ticks) {\r\n    return ticks.div(10000).toNumber();\r\n}\r\nexport function fromDays(d) {\r\n    return create(d, 0, 0, 0);\r\n}\r\nexport function fromHours(h) {\r\n    return create(h, 0, 0);\r\n}\r\nexport function fromMinutes(m) {\r\n    return create(0, m, 0);\r\n}\r\nexport function fromSeconds(s) {\r\n    return create(0, 0, s);\r\n}\r\nexport function days(ts) {\r\n    return Math.floor(ts / 86400000);\r\n}\r\nexport function hours(ts) {\r\n    return Math.floor(ts % 86400000 / 3600000);\r\n}\r\nexport function minutes(ts) {\r\n    return Math.floor(ts % 3600000 / 60000);\r\n}\r\nexport function seconds(ts) {\r\n    return Math.floor(ts % 60000 / 1000);\r\n}\r\nexport function milliseconds(ts) {\r\n    return Math.floor(ts % 1000);\r\n}\r\nexport function ticks(ts) {\r\n    return Long.fromNumber(ts).mul(10000);\r\n}\r\nexport function totalDays(ts) {\r\n    return ts / 86400000;\r\n}\r\nexport function totalHours(ts) {\r\n    return ts / 3600000;\r\n}\r\nexport function totalMinutes(ts) {\r\n    return ts / 60000;\r\n}\r\nexport function totalSeconds(ts) {\r\n    return ts / 1000;\r\n}\r\nexport function negate(ts) {\r\n    return ts * -1;\r\n}\r\nexport function add(ts1, ts2) {\r\n    return ts1 + ts2;\r\n}\r\nexport function subtract(ts1, ts2) {\r\n    return ts1 - ts2;\r\n}\r\nexport function compare(x, y) {\r\n    return utilCompare(x, y);\r\n}\r\nexport function compareTo(x, y) {\r\n    return utilCompare(x, y);\r\n}\r\nexport function duration(x) {\r\n    return Math.abs(x);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/fable-core/TimeSpan.js\n// module id = 16\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 17\n// module chunks = 0","import * as Evaluator from \"./hmrpEvaluator\";\n\nfunction guid() \n{\n    function s4() \n    {\n        return Math.floor((1 + Math.random()) * 0x10000)\n            .toString(16)\n            .substring(1);\n    }\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\n\nvar computations = {};\nvar NEW_STATE_CASE = \"NewState\";\nvar END_CASE =  \"End\";\n\nvar postStop = function()\n{\n    var obj = {\n        Case : END_CASE,\n        Fields : [\"Computation canceled.\"]\n    };\n    postMessage(obj);\n}\n\nvar postData = function(msg)\n{\n    if (msg.Case === NEW_STATE_CASE)\n    {\n        var struct = msg.Fields[0];\n        var newInputs = [];\n        for(var i = 0; i < struct.Inputs.length; i++)\n        {\n            newInputs.push(struct.Inputs[i]);\n        }\n        struct.Inputs = newInputs;\n\n        var newOutputs = [];\n        for(var i = 0; i < struct.Outputs.length; i++)\n        {\n            newOutputs.push(struct.Outputs[i]);\n        }\n        struct.Outputs = newOutputs;\n\n        var newRegisters = [];\n        for(var i = 0; i < struct.Registers.length; i++)\n        {\n            newRegisters.push(struct.Registers[i]);\n        }\n        struct.Registers = newRegisters;\n    }\n    postMessage(msg);\n};\n\nonmessage = function(e) \n{\n    var uuid = guid();\n\n    if (e.data === \"STOP\")\n    {\n        for (var key in computations) \n        {\n            if (!computations.hasOwnProperty(key)) continue;\n\n            var obj = computations[key];\n            obj.shouldContinue = false;\n            obj.hasBeenStopped = true;\n        }\n    }\n    else\n    {\n        var initialState = Evaluator.runFirstStep(e.data);\n        postData(initialState);\n        computations[uuid] = {\n            shouldContinue : initialState.Case === NEW_STATE_CASE,\n            state : initialState,\n            hasBeenStopped : false,\n        };\n\n        var runRecursively = function() {\n            if (computations[uuid].shouldContinue === true)\n            {\n                setTimeout(function ()  \n                {\n                    var newState = Evaluator.runStep(computations[uuid].state.Fields[0]);\n                    postData(newState);\n                    computations[uuid].shouldContinue = computations[uuid].shouldContinue && (newState.Case === NEW_STATE_CASE);\n                    computations[uuid].state = newState;\n                    if (computations[uuid].shouldContinue)\n                    {\n                        runRecursively();\n                    }\n                    else\n                    {\n                        if (newState.Case === NEW_STATE_CASE && computations[uuid].hasBeenStopped)\n                        {\n                            postStop();\n                        }\n                    }\n                }, 0);\n            }\n        }\n\n        runRecursively();\n    }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./output/worker.js\n// module id = 18\n// module chunks = 0"],"sourceRoot":""}